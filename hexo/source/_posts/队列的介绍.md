---
title: 队列的介绍
tags:
  - CLRS
  - Algorithm
categories: Algorithm
comments: true
copyright: true
abbrlink: 2bf9cb8
date: 2017-05-25 16:39:33
updated: 2017-05-25 17:39:33
---

### 队列的说明

队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

![](http://oc1mf55gf.bkt.clouddn.com/algorithm20170525001.png)

<!--more-->

### 队列的实现

类似栈一样，同样我们可以用链表或者数组来实现队列，用数组实现的时候，因为数组空间的限制，我们可以把它实现成循环队列。

#### 通过链表实现
通过链表来实现队列，可在Github上查看：[链接](https://github.com/vitahlin/Algorithm/blob/master/CLRS/Chapter10/queue_1.cpp)

```c
#include<iostream>
using namespace std;

template <class T>
class Node {
  public:
    T data;	// 数组内容
    Node<T> *next; // 指向下一个节点的指针
};

template <class T>
class Queue {
  public:
    Queue();
    ~Queue();

    bool enQueue(const T &);	// 入队列
    bool deQueue();	// 出队列
    bool isEmpty();	// 判断队列是否为空
    int getSize();	// 获取队列的大小
    void printQueue();	// 打印队列

  private:
    Node<T> *head;
    Node<T> *tail;
};

// 构造函数，初始化队列节点
template <class T>
Queue<T>::Queue() {
    Node<T> *new_queue = new Node<T>();
    new_queue->next = NULL;
    head = new_queue;
    tail = new_queue;

    cout << "初始化队列" << endl;
}

// 析构函数
template <class T>
Queue<T>::~Queue() {
    int delete_node_count = 0;

    while(head->next != NULL) {
        Node<T> *p = head->next;
        head->next = p->next;
        delete p;
        delete_node_count++;
    }

    if(head == tail) {
        delete head;
    }

    cout << "队列空间释放，共 " << delete_node_count << " 个节点" << endl;
}

// 入队列操作
template <class T>
bool Queue<T>::enQueue(const T &a) {
    Node<T> *p = new Node<T>();
    p->data = a;
    tail->next = p;
    tail = p;
    cout << "入队列 : " << a << endl;
    return true;
}

// 出队列操作
template <class T>
bool Queue<T>::deQueue() {
    if(isEmpty()) {
        return false;
    }

    Node<T> *p = head->next;
    head->next = p->next;
    if(p == tail) {
        head = tail;
    }

    cout << "出队列 : " << p->data << endl;
    delete p;
    return true;
}

// 判断队列是否为空
template <class T>
bool Queue<T>::isEmpty() {
    return head == tail ? true : false;
}

// 获取队列大小
template <class T>
int Queue<T>::getSize() {

    int queue_size = 0;
    if(isEmpty()) {
        return queue_size;
    } else {
        Node<T> *p = new Node<T>();
        p = head->next;
        while(p != NULL) {
            queue_size++;
            p = p->next;
        }

        return queue_size;
    }
}

// 队列内容打印
template <class T>
void Queue<T>::printQueue() {
    Node<T> *p = head->next;
    cout << endl << "队列大小 : " << getSize() << " , " << "队列头 ————> 队列尾:" << endl << "[ ";
    while(p != NULL) {
        cout << p->data << " ";
        p = p->next;
    }

    cout << "]" << endl << endl;
}

int main() {
    Queue<int> *my_queue = new Queue<int>();
    my_queue->printQueue();

    my_queue->enQueue(1);
    my_queue->enQueue(2);
    my_queue->enQueue(3);
    my_queue->enQueue(4);
    my_queue->printQueue();

    my_queue->deQueue();
    my_queue->deQueue();
    my_queue->printQueue();

    delete my_queue;
    return 0;
}
```

#### 通过数组实现
通过数组来实现循环队列，可在Github上查看：[链接](https://github.com/vitahlin/Algorithm/blob/master/CLRS/Chapter10/queue_2.cpp)

```c 
#include<iostream>
using namespace std;

#define DEFAULT_QUEUE_SIZE 5

template <class T>
class Queue {
  private:
  public:
    T * queue_array;	// 队列空间指针
    int front;	// 队列头部
    int rear;	// 队列尾部
    int max_size;	// 队列元素最大数量
    int size; // 当前队列大小
  public:
    Queue(int size = DEFAULT_QUEUE_SIZE);
    ~Queue();

    bool isFull();
    bool isEmpty();
    int getSize ();

    bool enQueue(T elem);
    bool deQueue();

    void printQueue();
};

// 构造函数，初始化队列数组的大小
template <class T>
Queue<T>::Queue(int capacity) {
    queue_array = new T[capacity];
    front = rear = 0;
    max_size = capacity;
    size = 0;
    cout << "队列初始化,大小为" << capacity << endl << endl;
}

// 析构函数，释放数组空间
template <class T>
Queue<T>::~Queue() {
    delete [] queue_array;
}

// 获取当前队列中元素数量
template <class T>
int Queue<T>::getSize() {
    return size;
}

// 元素入队列
template <class T>
bool Queue<T>::enQueue(T elem) {
    if(getSize() == max_size) {
        cout << "队列已满，入队列失败" << endl;
        return false;
    } else {
        queue_array[rear] = elem;

        rear = rear + 1;
        rear = rear % max_size;
        size++;

        cout << "入队列:" << elem << endl;
        return true;
    }
}

// 元素出队列
template <class T>
bool Queue<T>::deQueue() {
    if(getSize() == 0) {
        cout << "队列为空，出队列失败" << endl;
        return false;
    } else {
        T de_value = queue_array[front];
        front = (front + 1) % max_size;
        size--;
        cout << "出队列:" << de_value << endl;
        return true;
    }
}

// 打印队列内容
template <class T>
void Queue<T>::printQueue() {
    cout << endl << "队列头 ————> 队列尾" << endl << "[ ";

    int temp_rear = rear;
    if(rear <= front) {
        temp_rear += max_size;
    }
    for(int i = front; i < temp_rear; i++) {
        cout << queue_array[i % max_size] << " ";
    }

    cout << "]" << endl << endl;
}


int main() {
    Queue<int> *my_queue = new Queue<int>();
    my_queue->enQueue(1);
    my_queue->enQueue(2);
    my_queue->enQueue(3);
    my_queue->enQueue(4);
    my_queue->enQueue(5);
    my_queue->printQueue();

    my_queue->deQueue();
    my_queue->printQueue();

    my_queue->enQueue(6);
    my_queue->printQueue();


    my_queue->deQueue();
    my_queue->printQueue();


    my_queue->deQueue();
    my_queue->printQueue();

    my_queue->enQueue(7);
    my_queue->printQueue();

    my_queue->enQueue(8);
    my_queue->printQueue();

    my_queue->enQueue(9);
    my_queue->printQueue();

    delete my_queue;
    return 0;
}
```