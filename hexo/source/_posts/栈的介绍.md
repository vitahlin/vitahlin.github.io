---
title: 栈的介绍
tags:
  - CLRS
  - Algorithm
categories: Algorithm
comments: true
copyright: true
abbrlink: ac930640
date: 2017-05-23 17:39:33
updated: 2017-05-23 17:39:33
---

### 栈模型
栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈道基本操作有 Push(进栈)和 Pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈有时又叫LIFO(先进后出)表。

栈的模型图如下所示：

![](http://oc1mf55gf.bkt.clouddn.com/algorithm20170523001.jpeg)

### 栈的实现
栈的概念比较简单，我们可以直接通过代码来理解栈的相关结构。

由于栈是一个表，因此任何实现表的方法都可以实现栈。在这里，用两个流行的实现方法，一种是使用指针，另外一种是使用数组。

<!--more-->

#### 数组实现

栈的数组实现，可在Github上面查看：[链接](https://github.com/vitahlin/Algorithm/blob/master/CLRS/Chapter10/stack_1.cpp)
```c 
#include<iostream>
using namespace std;

#define DEFAULT_STACK_SIZE 10

template <class T>
class Stack {
  private:
    T * stack_array;	// 栈空间指针
    int capacity;	// 栈的容量
    int top_index;	// 栈顶
  public:
    Stack(int size = DEFAULT_STACK_SIZE);
    ~Stack();

    bool isFull();
    bool isEmpty();
    bool push(T elem);
    bool pop();
    T getTop();
    void printStack();

};

// 构造函数，初始化栈数组的大小
template <class T>
Stack<T>::Stack(int size) {
    capacity = size;
    stack_array = new T[size];
    top_index = 0;
    cout << "栈初始化,大小为" << size << endl << endl;
}

// 析构函数，释放数组空间
template <class T>
Stack<T>::~Stack() {
    delete [] stack_array;
}

// 判断栈是否已经满
template <class T>
bool Stack<T>::isFull() {
    return capacity == top_index ? true : false;
}

// 判断栈是否为空
template <class T>
bool Stack<T>::isEmpty() {
    return top_index == 0 ? true : false;
}

// 元素入栈
template <class T>
bool Stack<T>::push(T elem) {
    if(isFull()) {
        return false;
    }

    stack_array[top_index] = elem;
    top_index++;
    cout << "入栈:" << elem << endl;
    return true;
}

// 元素出栈
template <class T>
bool Stack<T>::pop() {
    if(top_index <= 0) {
        return false;
    }

    top_index--;
    cout << "执行出栈" << endl;
    return true;
}

// 获取栈顶元素
template <class T>
T Stack<T>::getTop() {
    if(!isEmpty()) {
        return stack_array[top_index - 1];
    } else {
        return 0;
    }
}

// 打印栈内容
template <class T>
void Stack<T>::printStack() {
    cout << endl << "栈顶 ————> 栈底" << endl << "[ ";
    for(int i = top_index - 1; i >= 0; i--) {
        cout << stack_array[i] << " ";
    }

    cout << "]" << endl << endl;
}


int main() {
    Stack<int> *my_stack = new Stack<int>();
    my_stack->push(4);
    my_stack->push(5);
    my_stack->printStack();

    my_stack->pop();
    my_stack->printStack();

    delete my_stack;
    return 0;
}
```

#### 链表实现

栈的链表实现，可在Github上查看:[链接](https://github.com/vitahlin/Algorithm/blob/master/CLRS/Chapter10/stack_2.cpp)
```c 
#include<iostream>
using namespace std;

// 栈中每个元素的节点
template <class T>
class Node {
  public:
    T data;
    Node<T> *next;
};

template <class T>
class Stack {
  public:
    Stack();
    ~Stack();

    bool pop();
    void push(const T&);

    bool isEmpty();
    void printStack();

  private:
    Node<T> *top;
};

// 构造函数，初始化空栈
template <class T>
Stack<T>::Stack() {
    top = NULL;
    cout << endl << "初始化空栈" << endl;
}

// 栈析构函数，需要释放栈中的每个节点
template <class T>
Stack<T>::~Stack() {
    int node_count = 0;
    Node<T> *p = NULL;
    while(top) {
        p = top;
        top = top->next;
        delete p;
        node_count++;
    }

    cout << endl << "栈空间释放，共 " << node_count << " 个节点" << endl;
}

// 判断栈是否为空
template <class T>
bool Stack<T>::isEmpty() {
    if(top) {
        return false;
    }

    return true;
}

// 出栈
template <class T>
bool Stack<T>::pop() {
    if(!isEmpty()) {
        Node<T> * p = top;

        cout << "出栈 : " << p->data << endl;

        top = top->next;
        delete p;
        return true;
    }

    return false;
}

// 入栈
template <class T>
void Stack<T>::push(const T &a) {
    Node<T> *p = new Node<T>();

    p->next = top;
    p->data = a;
    top = p;

    cout << "入栈 : " << a << endl;
}

template <class T>
void Stack<T>::printStack() {
    Node<T> *p = top;
    cout << endl << "栈顶 ————> 栈底" << endl << "[ ";
    while(p) {
        cout << p->data << " ";
        p = p->next;
    }

    cout << "]" << endl << endl;
}


int main() {
    Stack<int> *my_stack = new Stack<int>();
    my_stack->printStack();

    my_stack->push(5);
    my_stack->push(50);
    my_stack->push(500);

    my_stack->printStack();

    my_stack->pop();
    my_stack->printStack();


    my_stack->pop();
    my_stack->printStack();

    delete my_stack;
    return 0;
}
```

代码里面都有基本的注释，这里不做具体的介绍。

### 栈的应用

现在的计算机其实已经将栈操作作为它的指令系统的一部分，栈很可能是计算机科学里面在数组之后最基本的数据结构。

至于对栈的应用，我们可以用栈来快速方便的实现一些小问题，比如说进制间的转换、平衡符号的判断、后缀表达式的计算、中缀表达式转后缀表达式以及函数的调用等等。