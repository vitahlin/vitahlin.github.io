<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mysql on Vitah Lin</title><link>https://www.vitahlin.com/categories/mysql/</link><description>Recent content in mysql on Vitah Lin</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Chh</copyright><lastBuildDate>Tue, 05 Apr 2022 21:57:40 +0800</lastBuildDate><atom:link href="https://www.vitahlin.com/categories/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>Mysql数据库设计规范</title><link>https://www.vitahlin.com/posts/mysql-design-guideline/</link><pubDate>Tue, 15 Mar 2022 12:00:00 +0800</pubDate><guid>https://www.vitahlin.com/posts/mysql-design-guideline/</guid><description>表结构设计 不在数据库做运算，同时运算的字段也无法使用索引 控制单表数量，纯 INT 不超过1000W行，含 CHAR 不超过500W 合理分表，比如按用户 UserId ，日期，地区等 单库不超过300-400个表 单表分表个数必须控制在1024个以内 表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快 单表字段上线控制在20-50个 单表不超过50个纯 INT 字段，不超过20个 CHAR(10) 字段 单表不超过200Byte 适当牺牲范式、加入适当冗余 字段设计 选用合适的数值字段类型，根据业务区分使用 tinyint/int/bigint，分别会占用1/4/8字节 表示是否概念的字段，使用is_xxx命名，数据类型为UNSIGNED TINYINT（1表示是，0表示否） 小数类型为DECIMAL，禁止使用float、double，存在精度缺损 时间类型为BIGINT，统一存储时间戳 字段长度固定或者长度近似的业务场景，适合使用char，能减少碎片，查询性能高 字段长度相差较大，或者更新较少的业务场景适合使用VARCHAR，能够减少空间 将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小 避免使用ENUM，因为增加新类型需要修改表结构 避免使用NULL字段，因为很难进行查询优化，含NULL复合索引无效，NULL列加索引需要额外空间，NULL只能采用 IS NULL或者IS NOT NULL，而在=、!=、in、not in时有大坑 少用并拆分TEXT/BLOB，处理性能远低于VARCHAR，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据） 不在数据库中存图片，仅保存图片存储地址（文件类同） 使用INT UNSIGNED存储IPv4，不要使用CHAR(15) 使用VARCHAR(20)存储手机号，不要使用整数（涉及到国家代号，可能出现+、-、()等字符，VARCHAR也可以模糊查询，例如：like ‘138%’） 索引规范 自增列或全局ID做InnoDB主键，推荐用于独立业务的AUTO_INCREMENT列或者全局ID生成器做代理主键 非唯一索引命名idx_字段名 唯一索引命名uk_字段名 主键索引命名pk_xxx 单表索引数量控制在5个以内 合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20% 字符字段必须建前缀索引，like '%name%'不会使用索引 不在索引列做运算，否则无法使用索引，导致全表扫描 尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈） 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)相当于建立了(a)、(a,b)、(a,b,c) 防止因字段类型不同造成的隐式转换，导致索引失效 SQL规范 SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死 拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM 事务/连接使用原则：即开即用，用完即关 与事务无关操作放到事务外面，减少资源的占用 不破坏一致性前提下，使用多个短事务代替长事务 尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责 尽量不用select *，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源 同一个字段，将OR改写为IN，注意IN的个数，建议少于200 不同字段，将OR改成UNION select id from t where phone = ’159′ or name = ‘john’; =&amp;gt; select id from t where phone=’159′ union select id from t where name=’jonh’ 避免负向查询和%前缀模糊查询，使用不了索引，导致全表扫描 尽量不用、少用COUNT(*) LIMIT 高效分页，传统分布 SELECT id FROM user LIMIT 10000, 10，偏移量越大则越慢；推荐分页 SELECT id FROM user WHERE id &amp;gt;= 10000 LIMIT 10 若无需对结果进行去重，使用 UNION ALL 而非 UNION， UNION 有去重开销 高并发DB禁止进行两个表以上的 JOIN 同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效） 避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算 尽量不用 INSERT .</description></item><item><title>Mysql explain命令详解</title><link>https://www.vitahlin.com/posts/mysql-explain/</link><pubDate>Tue, 05 Apr 2022 21:57:40 +0800</pubDate><guid>https://www.vitahlin.com/posts/mysql-explain/</guid><description>测试数据 DROP TABLE IF EXISTS `actor`; CREATE TABLE `actor` ( `id` int(11) NOT NULL, `name` varchar(45) DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1, &amp;#39;a&amp;#39;, &amp;#39;2017-12-29 10:27:18&amp;#39;), (2, &amp;#39;b&amp;#39;, &amp;#39;2017-12-29 15:27:18&amp;#39;), (3, &amp;#39;c&amp;#39;, &amp;#39;2017-12-29 15:27:18&amp;#39;); DROP TABLE IF EXISTS `film`; CREATE TABLE `film` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_name` (`name`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; INSERT INTO `film` (`id`, `name`) VALUES (3, &amp;#39;film0&amp;#39;), (1, &amp;#39;film1&amp;#39;), (2, &amp;#39;film2&amp;#39;);</description></item></channel></rss>