<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Mysql数据库设计规范 - Vitah Lin</title><meta name=description content="表结构设计  不在数据库做运算，同时运算的字段也无法使用索引 控制单表数量，纯 INT 不超过1000W行，含 CHAR 不超过500W 合理分表，比如按用户 UserId ，日期，地区等 单库不超过300-400个表 单表分表个数必须控制在1024个以内 表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快 单表字段上线控制在20-50个 单表不超过50个纯 INT 字段，不超过20个 CHAR(10) 字段 单表不超过200Byte 适当牺牲范式、加入适当冗余  字段设计  选用合适的数值字段类型，根据业务区分使用 tinyint/int/bigint，分别会占用1/4/8字节 表示是否概念的字段，使用is_xxx命名，数据类型为UNSIGNED TINYINT（1表示是，0表示否） 小数类型为DECIMAL，禁止使用float、double，存在精度缺损 时间类型为BIGINT，统一存储时间戳 字段长度固定或者长度近似的业务场景，适合使用char，能减少碎片，查询性能高 字段长度相差较大，或者更新较少的业务场景适合使用VARCHAR，能够减少空间 将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小 避免使用ENUM，因为增加新类型需要修改表结构 避免使用NULL字段，因为很难进行查询优化，含NULL复合索引无效，NULL列加索引需要额外空间，NULL只能采用 IS NULL或者IS NOT NULL，而在=、!=、in、not in时有大坑 少用并拆分TEXT/BLOB，处理性能远低于VARCHAR，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据） 不在数据库中存图片，仅保存图片存储地址（文件类同） 使用INT UNSIGNED存储IPv4，不要使用CHAR(15) 使用VARCHAR(20)存储手机号，不要使用整数（涉及到国家代号，可能出现+、-、()等字符，VARCHAR也可以模糊查询，例如：like ‘138%’）  索引规范  自增列或全局ID做InnoDB主键，推荐用于独立业务的AUTO_INCREMENT列或者全局ID生成器做代理主键 非唯一索引命名idx_字段名 唯一索引命名uk_字段名 主键索引命名pk_xxx 单表索引数量控制在5个以内 合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20% 字符字段必须建前缀索引，like '%name%'不会使用索引 不在索引列做运算，否则无法使用索引，导致全表扫描 尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈） 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)相当于建立了(a)、(a,b)、(a,b,c) 防止因字段类型不同造成的隐式转换，导致索引失效  SQL规范  SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死 拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM 事务/连接使用原则：即开即用，用完即关 与事务无关操作放到事务外面，减少资源的占用 不破坏一致性前提下，使用多个短事务代替长事务 尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责 尽量不用select *，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源 同一个字段，将OR改写为IN，注意IN的个数，建议少于200 不同字段，将OR改成UNION  select id from t where phone = ’159′ or name = ‘john’; => select id from t where phone=’159′ union select id from t where name=’jonh’  避免负向查询和%前缀模糊查询，使用不了索引，导致全表扫描 尽量不用、少用COUNT(*) LIMIT 高效分页，传统分布 SELECT id FROM user LIMIT 10000, 10，偏移量越大则越慢；推荐分页 SELECT id FROM user WHERE id >= 10000 LIMIT 10 若无需对结果进行去重，使用 UNION ALL 而非 UNION， UNION 有去重开销 高并发DB禁止进行两个表以上的 JOIN 同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效） 避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算 尽量不用 INSERT ."><meta name=author content="vitahlin"><link rel="preload stylesheet" as=style href=https://www.vitahlin.com/app.min.css><link rel="preload stylesheet" as=style href=https://www.vitahlin.com/an-old-hope.min.css><script defer src=https://www.vitahlin.com/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=https://www.vitahlin.com/theme.png><link rel=preload as=image href=https://www.vitahlin.com/github.svg><link rel=icon href=https://www.vitahlin.com/favicon.ico><link rel=apple-touch-icon href=https://www.vitahlin.com/apple-touch-icon.png><meta name=generator content="Hugo 0.96.0"><meta property="og:title" content="Mysql数据库设计规范"><meta property="og:description" content="表结构设计  不在数据库做运算，同时运算的字段也无法使用索引 控制单表数量，纯 INT 不超过1000W行，含 CHAR 不超过500W 合理分表，比如按用户 UserId ，日期，地区等 单库不超过300-400个表 单表分表个数必须控制在1024个以内 表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快 单表字段上线控制在20-50个 单表不超过50个纯 INT 字段，不超过20个 CHAR(10) 字段 单表不超过200Byte 适当牺牲范式、加入适当冗余  字段设计  选用合适的数值字段类型，根据业务区分使用 tinyint/int/bigint，分别会占用1/4/8字节 表示是否概念的字段，使用is_xxx命名，数据类型为UNSIGNED TINYINT（1表示是，0表示否） 小数类型为DECIMAL，禁止使用float、double，存在精度缺损 时间类型为BIGINT，统一存储时间戳 字段长度固定或者长度近似的业务场景，适合使用char，能减少碎片，查询性能高 字段长度相差较大，或者更新较少的业务场景适合使用VARCHAR，能够减少空间 将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小 避免使用ENUM，因为增加新类型需要修改表结构 避免使用NULL字段，因为很难进行查询优化，含NULL复合索引无效，NULL列加索引需要额外空间，NULL只能采用 IS NULL或者IS NOT NULL，而在=、!=、in、not in时有大坑 少用并拆分TEXT/BLOB，处理性能远低于VARCHAR，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据） 不在数据库中存图片，仅保存图片存储地址（文件类同） 使用INT UNSIGNED存储IPv4，不要使用CHAR(15) 使用VARCHAR(20)存储手机号，不要使用整数（涉及到国家代号，可能出现+、-、()等字符，VARCHAR也可以模糊查询，例如：like ‘138%’）  索引规范  自增列或全局ID做InnoDB主键，推荐用于独立业务的AUTO_INCREMENT列或者全局ID生成器做代理主键 非唯一索引命名idx_字段名 唯一索引命名uk_字段名 主键索引命名pk_xxx 单表索引数量控制在5个以内 合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20% 字符字段必须建前缀索引，like '%name%'不会使用索引 不在索引列做运算，否则无法使用索引，导致全表扫描 尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈） 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)相当于建立了(a)、(a,b)、(a,b,c) 防止因字段类型不同造成的隐式转换，导致索引失效  SQL规范  SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死 拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM 事务/连接使用原则：即开即用，用完即关 与事务无关操作放到事务外面，减少资源的占用 不破坏一致性前提下，使用多个短事务代替长事务 尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责 尽量不用select *，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源 同一个字段，将OR改写为IN，注意IN的个数，建议少于200 不同字段，将OR改成UNION  select id from t where phone = ’159′ or name = ‘john’; => select id from t where phone=’159′ union select id from t where name=’jonh’  避免负向查询和%前缀模糊查询，使用不了索引，导致全表扫描 尽量不用、少用COUNT(*) LIMIT 高效分页，传统分布 SELECT id FROM user LIMIT 10000, 10，偏移量越大则越慢；推荐分页 SELECT id FROM user WHERE id >= 10000 LIMIT 10 若无需对结果进行去重，使用 UNION ALL 而非 UNION， UNION 有去重开销 高并发DB禁止进行两个表以上的 JOIN 同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效） 避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算 尽量不用 INSERT ."><meta property="og:type" content="article"><meta property="og:url" content="https://www.vitahlin.com/post/mysql-design-guideline/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-15T12:00:00+08:00"><meta property="article:modified_time" content="2022-03-15T12:00:00+08:00"><meta itemprop=name content="Mysql数据库设计规范"><meta itemprop=description content="表结构设计  不在数据库做运算，同时运算的字段也无法使用索引 控制单表数量，纯 INT 不超过1000W行，含 CHAR 不超过500W 合理分表，比如按用户 UserId ，日期，地区等 单库不超过300-400个表 单表分表个数必须控制在1024个以内 表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快 单表字段上线控制在20-50个 单表不超过50个纯 INT 字段，不超过20个 CHAR(10) 字段 单表不超过200Byte 适当牺牲范式、加入适当冗余  字段设计  选用合适的数值字段类型，根据业务区分使用 tinyint/int/bigint，分别会占用1/4/8字节 表示是否概念的字段，使用is_xxx命名，数据类型为UNSIGNED TINYINT（1表示是，0表示否） 小数类型为DECIMAL，禁止使用float、double，存在精度缺损 时间类型为BIGINT，统一存储时间戳 字段长度固定或者长度近似的业务场景，适合使用char，能减少碎片，查询性能高 字段长度相差较大，或者更新较少的业务场景适合使用VARCHAR，能够减少空间 将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小 避免使用ENUM，因为增加新类型需要修改表结构 避免使用NULL字段，因为很难进行查询优化，含NULL复合索引无效，NULL列加索引需要额外空间，NULL只能采用 IS NULL或者IS NOT NULL，而在=、!=、in、not in时有大坑 少用并拆分TEXT/BLOB，处理性能远低于VARCHAR，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据） 不在数据库中存图片，仅保存图片存储地址（文件类同） 使用INT UNSIGNED存储IPv4，不要使用CHAR(15) 使用VARCHAR(20)存储手机号，不要使用整数（涉及到国家代号，可能出现+、-、()等字符，VARCHAR也可以模糊查询，例如：like ‘138%’）  索引规范  自增列或全局ID做InnoDB主键，推荐用于独立业务的AUTO_INCREMENT列或者全局ID生成器做代理主键 非唯一索引命名idx_字段名 唯一索引命名uk_字段名 主键索引命名pk_xxx 单表索引数量控制在5个以内 合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20% 字符字段必须建前缀索引，like '%name%'不会使用索引 不在索引列做运算，否则无法使用索引，导致全表扫描 尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈） 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)相当于建立了(a)、(a,b)、(a,b,c) 防止因字段类型不同造成的隐式转换，导致索引失效  SQL规范  SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死 拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM 事务/连接使用原则：即开即用，用完即关 与事务无关操作放到事务外面，减少资源的占用 不破坏一致性前提下，使用多个短事务代替长事务 尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责 尽量不用select *，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源 同一个字段，将OR改写为IN，注意IN的个数，建议少于200 不同字段，将OR改成UNION  select id from t where phone = ’159′ or name = ‘john’; => select id from t where phone=’159′ union select id from t where name=’jonh’  避免负向查询和%前缀模糊查询，使用不了索引，导致全表扫描 尽量不用、少用COUNT(*) LIMIT 高效分页，传统分布 SELECT id FROM user LIMIT 10000, 10，偏移量越大则越慢；推荐分页 SELECT id FROM user WHERE id >= 10000 LIMIT 10 若无需对结果进行去重，使用 UNION ALL 而非 UNION， UNION 有去重开销 高并发DB禁止进行两个表以上的 JOIN 同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效） 避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算 尽量不用 INSERT ."><meta itemprop=datePublished content="2022-03-15T12:00:00+08:00"><meta itemprop=dateModified content="2022-03-15T12:00:00+08:00"><meta itemprop=wordCount content="166"><meta itemprop=keywords content="mysql,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql数据库设计规范"><meta name=twitter:description content="表结构设计  不在数据库做运算，同时运算的字段也无法使用索引 控制单表数量，纯 INT 不超过1000W行，含 CHAR 不超过500W 合理分表，比如按用户 UserId ，日期，地区等 单库不超过300-400个表 单表分表个数必须控制在1024个以内 表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快 单表字段上线控制在20-50个 单表不超过50个纯 INT 字段，不超过20个 CHAR(10) 字段 单表不超过200Byte 适当牺牲范式、加入适当冗余  字段设计  选用合适的数值字段类型，根据业务区分使用 tinyint/int/bigint，分别会占用1/4/8字节 表示是否概念的字段，使用is_xxx命名，数据类型为UNSIGNED TINYINT（1表示是，0表示否） 小数类型为DECIMAL，禁止使用float、double，存在精度缺损 时间类型为BIGINT，统一存储时间戳 字段长度固定或者长度近似的业务场景，适合使用char，能减少碎片，查询性能高 字段长度相差较大，或者更新较少的业务场景适合使用VARCHAR，能够减少空间 将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小 避免使用ENUM，因为增加新类型需要修改表结构 避免使用NULL字段，因为很难进行查询优化，含NULL复合索引无效，NULL列加索引需要额外空间，NULL只能采用 IS NULL或者IS NOT NULL，而在=、!=、in、not in时有大坑 少用并拆分TEXT/BLOB，处理性能远低于VARCHAR，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据） 不在数据库中存图片，仅保存图片存储地址（文件类同） 使用INT UNSIGNED存储IPv4，不要使用CHAR(15) 使用VARCHAR(20)存储手机号，不要使用整数（涉及到国家代号，可能出现+、-、()等字符，VARCHAR也可以模糊查询，例如：like ‘138%’）  索引规范  自增列或全局ID做InnoDB主键，推荐用于独立业务的AUTO_INCREMENT列或者全局ID生成器做代理主键 非唯一索引命名idx_字段名 唯一索引命名uk_字段名 主键索引命名pk_xxx 单表索引数量控制在5个以内 合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20% 字符字段必须建前缀索引，like '%name%'不会使用索引 不在索引列做运算，否则无法使用索引，导致全表扫描 尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈） 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)相当于建立了(a)、(a,b)、(a,b,c) 防止因字段类型不同造成的隐式转换，导致索引失效  SQL规范  SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死 拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM 事务/连接使用原则：即开即用，用完即关 与事务无关操作放到事务外面，减少资源的占用 不破坏一致性前提下，使用多个短事务代替长事务 尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责 尽量不用select *，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源 同一个字段，将OR改写为IN，注意IN的个数，建议少于200 不同字段，将OR改成UNION  select id from t where phone = ’159′ or name = ‘john’; => select id from t where phone=’159′ union select id from t where name=’jonh’  避免负向查询和%前缀模糊查询，使用不了索引，导致全表扫描 尽量不用、少用COUNT(*) LIMIT 高效分页，传统分布 SELECT id FROM user LIMIT 10000, 10，偏移量越大则越慢；推荐分页 SELECT id FROM user WHERE id >= 10000 LIMIT 10 若无需对结果进行去重，使用 UNION ALL 而非 UNION， UNION 有去重开销 高并发DB禁止进行两个表以上的 JOIN 同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效） 避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算 尽量不用 INSERT ."></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=https://www.vitahlin.com/>Vitah Lin</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=/about/>About</a></nav><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/vitahlin target=_blank></a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Mar 15, 2022</time>
<span>vitahlin</span></p><h1>Mysql数据库设计规范</h1></header><section class=post-content><h2 id=表结构设计>表结构设计</h2><ul><li>不在数据库做运算，同时运算的字段也无法使用索引</li><li>控制单表数量，纯 <code>INT</code> 不超过1000W行，含 <code>CHAR</code> 不超过500W</li><li>合理分表，比如按用户 UserId ，日期，地区等</li><li>单库不超过300-400个表</li><li>单表分表个数必须控制在1024个以内</li><li>表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快</li><li>单表字段上线控制在20-50个</li><li>单表不超过50个纯 <code>INT</code> 字段，不超过20个 <code>CHAR(10)</code> 字段</li><li>单表不超过<code>200Byte</code></li><li>适当牺牲范式、加入适当冗余</li></ul><h2 id=字段设计>字段设计</h2><ul><li>选用合适的数值字段类型，根据业务区分使用 <code>tinyint/int/bigint</code>，分别会占用1/4/8字节</li><li>表示是否概念的字段，使用<code>is_xxx</code>命名，数据类型为<code>UNSIGNED TINYINT</code>（1表示是，0表示否）</li><li>小数类型为<code>DECIMAL</code>，禁止使用<code>float、double</code>，存在精度缺损</li><li>时间类型为<code>BIGINT</code>，统一存储时间戳</li><li>字段长度固定或者长度近似的业务场景，适合使用<code>char</code>，能减少碎片，查询性能高</li><li>字段长度相差较大，或者更新较少的业务场景适合使用<code>VARCHAR</code>，能够减少空间</li><li>将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小</li><li>避免使用<code>ENUM</code>，因为增加新类型需要修改表结构</li><li>避免使用<code>NULL</code>字段，因为很难进行查询优化，含<code>NULL</code>复合索引无效，<code>NULL</code>列加索引需要额外空间，<code>NULL</code>只能采用 <code>IS NULL</code>或者<code>IS NOT NULL</code>，而在<code>=、!=、in、not in</code>时有大坑</li><li>少用并拆分<code>TEXT/BLOB</code>，处理性能远低于<code>VARCHAR</code>，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据）</li><li>不在数据库中存图片，仅保存图片存储地址（文件类同）</li><li>使用<code>INT UNSIGNED</code>存储IPv4，不要使用<code>CHAR(15)</code></li><li>使用<code>VARCHAR(20)</code>存储手机号，不要使用整数（涉及到国家代号，可能出现<code>+、-、()</code>等字符，<code>VARCHAR</code>也可以模糊查询，例如：<code>like ‘138%’</code>）</li></ul><h2 id=索引规范>索引规范</h2><ul><li>自增列或全局ID做InnoDB主键，推荐用于独立业务的<code>AUTO_INCREMENT</code>列或者全局ID生成器做代理主键</li><li>非唯一索引命名<code>idx_字段名</code></li><li>唯一索引命名<code>uk_字段名</code></li><li>主键索引命名<code>pk_xxx</code></li><li>单表索引数量控制在5个以内</li><li>合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20%</li><li>字符字段必须建前缀索引，<code>like '%name%'</code>不会使用索引</li><li>不在索引列做运算，否则无法使用索引，导致全表扫描</li><li>尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈）</li><li>非必要不要进行<code>JOIN</code>查询，如果要进行<code>JOIN</code>查询，被<code>JOIN</code>的字段必须类型相同，并建立索引</li><li>理解组合索引最左前缀原则，避免重复建设索引，如果建立了<code>(a,b,c)</code>相当于建立了<code>(a)、(a,b)、(a,b,c)</code></li><li>防止因字段类型不同造成的隐式转换，导致索引失效</li></ul><h2 id=sql规范>SQL规范</h2><ul><li>SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死</li><li>拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM</li><li>事务/连接使用原则：即开即用，用完即关</li><li>与事务无关操作放到事务外面，减少资源的占用</li><li>不破坏一致性前提下，使用多个短事务代替长事务</li><li>尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责</li><li>尽量不用<code>select *</code>，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源</li><li>同一个字段，将<code>OR</code>改写为<code>IN</code>，注意<code>IN</code>的个数，建议少于200</li><li>不同字段，将<code>OR</code>改成<code>UNION</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> t <span style=color:#66d9ef>where</span> phone <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>’</span><span style=color:#ae81ff>159</span><span style=color:#960050;background-color:#1e0010>′</span> <span style=color:#66d9ef>or</span> name <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>‘</span>john<span style=color:#960050;background-color:#1e0010>’</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> t <span style=color:#66d9ef>where</span> phone<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>’</span><span style=color:#ae81ff>159</span><span style=color:#960050;background-color:#1e0010>′</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>union</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> id <span style=color:#66d9ef>from</span> t <span style=color:#66d9ef>where</span> name<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>’</span>jonh<span style=color:#960050;background-color:#1e0010>’</span>
</span></span></code></pre></div><ul><li>避免负向查询和<code>%</code>前缀模糊查询，使用不了索引，导致全表扫描</li><li>尽量不用、少用<code>COUNT(*)</code></li><li><code>LIMIT</code> 高效分页，传统分布 <code>SELECT id FROM user LIMIT 10000, 10</code>，偏移量越大则越慢；推荐分页 <code>SELECT id FROM user WHERE id >= 10000 LIMIT 10</code></li><li>若无需对结果进行去重，使用 <code>UNION ALL</code> 而非 <code>UNION</code>， <code>UNION</code> 有去重开销</li><li>高并发DB禁止进行两个表以上的 <code>JOIN</code></li><li>同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效）</li><li>避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算</li><li>尽量不用 <code>INSERT ... SELECT</code></li><li>Load data 批量导入数据，尽量避开高峰期操作</li><li>使用 <code>EXPLAIN</code> 查看执行计划</li><li>观察慢查询日志</li><li><code>show processlist</code> 查看进程状态</li><li>MySQL子查询大部分情况下优化较差，特别是 <code>WHERE</code> 中使用 <code>IN id</code> 的子查询，一般可用 <code>JOIN</code> 改写</li></ul><h2 id=通用约定>通用约定</h2><ul><li>永远不在程序端显示加锁，外部锁对数据库不可控，高并发时是灾难</li><li>表存储引擎必须使用InnoDB</li><li>统一字符集为UTF8，乱码：SET NAMES UTF8，必要时候使用<code>utf8mb4</code>（utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它）</li><li>库表等名称统一用小写，MySQL库表大小写敏感，字段名的大小写不敏感（Linux VS win）</li><li>表名不使用复数名词</li><li>必备三个字段 <code>id, create_at, update_at</code></li><li>表命名最好加上<code>“业务名称_表的作用”</code></li><li>库名与服务名最好一致</li></ul></section><footer class=post-tags><a href=https://www.vitahlin.com/tags/mysql>mysql</a></footer><nav class=post-nav><a class=next href=https://www.vitahlin.com/post/use-clion-and-cmake-build-redis3/><span>macOS上用Clion CMake编译redis 3.0</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=https://www.vitahlin.com/>Vitah Lin</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>