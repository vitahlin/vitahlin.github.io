# Mysql数据库设计规范


## 表结构设计

- 不在数据库做运算，同时运算的字段也无法使用索引
- 控制单表数量，纯 `INT` 不超过1000W行，含 `CHAR` 不超过500W
- 合理分表，比如按用户 UserId ，日期，地区等
- 单库不超过300-400个表
- 单表分表个数必须控制在1024个以内
- 表字段少而精，有利于IO高效、全表遍历、表修复快、提高并发、alter table快
- 单表字段上线控制在20-50个
- 单表不超过50个纯 `INT` 字段，不超过20个 `CHAR(10)` 字段
- 单表不超过`200Byte`
- 适当牺牲范式、加入适当冗余

## 字段设计

- 选用合适的数值字段类型，根据业务区分使用 `tinyint/int/bigint`，分别会占用1/4/8字节
- 表示是否概念的字段，使用`is_xxx`命名，数据类型为`UNSIGNED TINYINT`（1表示是，0表示否）
- 小数类型为`DECIMAL`，禁止使用`float、double`，存在精度缺损
- 时间类型为`BIGINT`，统一存储时间戳
- 字段长度固定或者长度近似的业务场景，适合使用`char`，能减少碎片，查询性能高
- 字段长度相差较大，或者更新较少的业务场景适合使用`VARCHAR`，能够减少空间
- 将字符串转换为数字，因为数字类型比字符串类型索引更高效、查询更快、占用空间更小
- 避免使用`ENUM`，因为增加新类型需要修改表结构
- 避免使用`NULL`字段，因为很难进行查询优化，含`NULL`复合索引无效，`NULL`列加索引需要额外空间，`NULL`只能采用 `IS NULL`或者`IS NOT NULL`，而在`=、!=、in、not in`时有大坑
- 少用并拆分`TEXT/BLOB`，处理性能远低于`VARCHAR`，若必须使用则拆分单独的表（建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据）
- 不在数据库中存图片，仅保存图片存储地址（文件类同）
- 使用`INT UNSIGNED`存储IPv4，不要使用`CHAR(15)`
- 使用`VARCHAR(20)`存储手机号，不要使用整数（涉及到国家代号，可能出现`+、-、()`等字符，`VARCHAR`也可以模糊查询，例如：`like ‘138%’`）

## 索引规范

- 自增列或全局ID做InnoDB主键，推荐用于独立业务的`AUTO_INCREMENT`列或者全局ID生成器做代理主键
- 非唯一索引命名`idx_字段名`
- 唯一索引命名`uk_字段名`
- 主键索引命名`pk_xxx`
- 单表索引数量控制在5个以内
- 合理添加所以可以改善查询，但会减慢更小，并不是索引越多越好，索引字段最好不超过表字段的20%
- 字符字段必须建前缀索引，`like '%name%'`不会使用索引
- 不在索引列做运算，否则无法使用索引，导致全表扫描
- 尽量不用外键，高并发时容易死锁（外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈）
- 非必要不要进行`JOIN`查询，如果要进行`JOIN`查询，被`JOIN`的字段必须类型相同，并建立索引
- 理解组合索引最左前缀原则，避免重复建设索引，如果建立了`(a,b,c)`相当于建立了`(a)、(a,b)、(a,b,c)`
- 防止因字段类型不同造成的隐式转换，导致索引失效

## SQL规范

- SQL语句尽可能简单，一条SQL语句只能在一个CPU进行运算，5000+QPS的高并发中，可能一条大SQL就把整个数据库堵死
- 拆解成多条简单SQL，缓存命中率更高，用上更多的CPU；减少锁表时间，特别是MyISAM
- 事务/连接使用原则：即开即用，用完即关
- 与事务无关操作放到事务外面，减少资源的占用
- 不破坏一致性前提下，使用多个短事务代替长事务
- 尽可能避免使用存储过程、触发器、Event（调试、排错、迁移都比较困难，扩展性较差），减少使用Mysql函数对结果进行处理，由程序端负责
- 尽量不用`select *`，只取需要的数据列，不会占用更多的CPU、内存、IO、网络带宽资源
- 同一个字段，将`OR`改写为`IN`，注意`IN`的个数，建议少于200
- 不同字段，将`OR`改成`UNION`

```sql
select id from t where phone = ’159′ or name = ‘john’;
=>
select id from t where phone=’159′
union
select id from t where name=’jonh’
```

- 避免负向查询和`%`前缀模糊查询，使用不了索引，导致全表扫描
- 尽量不用、少用`COUNT(*)`
- `LIMIT` 高效分页，传统分布 `SELECT id FROM user LIMIT 10000, 10`，偏移量越大则越慢；推荐分页 `SELECT id FROM user WHERE id >= 10000 LIMIT 10`
- 若无需对结果进行去重，使用 `UNION ALL` 而非 `UNION`， `UNION` 有去重开销
- 高并发DB禁止进行两个表以上的 `JOIN`
- 同数据类型的列值进行比较（防止因字段类型不同造成的隐式转换，导致索引失效）
- 避免大SQL、大事务、大批量长时间占用系统资源而堵塞系统，一个SQL只能在一个CPU运算
- 尽量不用 `INSERT ... SELECT`
- Load data 批量导入数据，尽量避开高峰期操作
- 使用 `EXPLAIN` 查看执行计划
- 观察慢查询日志
- `show processlist` 查看进程状态
- MySQL子查询大部分情况下优化较差，特别是 `WHERE` 中使用 `IN id` 的子查询，一般可用 `JOIN` 改写

## 通用约定

- 永远不在程序端显示加锁，外部锁对数据库不可控，高并发时是灾难
- 表存储引擎必须使用InnoDB
- 统一字符集为UTF8，乱码：SET NAMES UTF8，必要时候使用`utf8mb4`（utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它）
- 库表等名称统一用小写，MySQL库表大小写敏感，字段名的大小写不敏感（Linux VS win）
- 表名不使用复数名词
- 必备三个字段 `id, create_at, update_at`
- 表命名最好加上`“业务名称_表的作用”`
- 库名与服务名最好一致

