[{"content":"示例表 表结构 1 2 3 4 5 6 7 8 9 10 11 12 13  DROPTABLEIFEXISTSemployees;CREATETABLE`employees`(`id`INT(11)NOTNULLAUTO_INCREMENT,`name`VARCHAR(24)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;姓名\u0026#39;,`age`INT(11)NOTNULLDEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;年龄\u0026#39;,`position`VARCHAR(20)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;职位\u0026#39;,`hire_time`TIMESTAMPNOTNULLDEFAULTCURRENT_TIMESTAMPCOMMENT\u0026#39;入职时间\u0026#39;,PRIMARYKEY(`id`),KEY`idx_name_age_position`(`name`,`age`,`position`)USINGBTREE)ENGINE=InnoDBAUTO_INCREMENT=1DEFAULTCHARSET=utf8COMMENT=\u0026#39;员工记录表\u0026#39;;  表数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  INSERTINTOemployees(name,age,position,hire_time)VALUES(\u0026#39;LiLei\u0026#39;,22,\u0026#39;manager\u0026#39;,NOW());INSERTINTOemployees(name,age,position,hire_time)VALUES(\u0026#39;HanMeimei\u0026#39;,23,\u0026#39;dev\u0026#39;,NOW());INSERTINTOemployees(name,age,position,hire_time)VALUES(\u0026#39;Lucy\u0026#39;,23,\u0026#39;dev\u0026#39;,NOW());#插入一些示例数据DROPPROCEDUREIFEXISTSinsert_emp;DELIMITER;;CREATEPROCEDUREinsert_emp()BEGINDECLAREiINT;SETi=1;WHILE(i\u0026lt;=100000)DOINSERTINTOemployees(name,age,position)VALUES(CONCAT(\u0026#39;zhuge\u0026#39;,i),i,\u0026#39;dev\u0026#39;);SETi=i+1;ENDWHILE;END;;DELIMITER;CALLinsert_emp();  联合索引第一个字段用范围查询 会不会走索引 联合索引第一个字段就用范围查找不会走索引，mysql内部可能觉得第一个字段就用范围查找，结果集应该很大，回表效率不高，还不如全表扫描。\n1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREname\u0026gt;\u0026#39;LiLei\u0026#39;ANDage=22ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99986, \u0026#34;filtered\u0026#34;: 0.5, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   强制走索引效果 使用了强制走索引让联合索引第一个字段范围查找也用索引，扫描的 rows 看上去也少了点，但最终但查找效率不一定会比全表扫描高，因为回表效率不高。\n1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesFORCEINDEX(idx_name_age_position)WHEREname\u0026gt;\u0026#39;LiLei\u0026#39;ANDage=22ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 49993, \u0026#34;filtered\u0026#34;: 1, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   强制走索引和不走索引效率对比 我们先关闭查询缓存，避免影响查询结果。\n1 2 3  # 关闭查询缓存 set global query_cache_size = 0; set global query_cache_type = 0;   不走索引结果 1 2 3 4 5 6 7 8  SELECT * FROM employees WHERE name \u0026gt; \u0026#39;LiLei\u0026#39;; vitah\u0026gt; SELECT * FROM employees WHERE name \u0026gt; \u0026#39;LiLei\u0026#39; [2022-03-26 22:11:22] 在 119 ms (execution: 14 ms, fetching: 105 ms) 内检索到从 1 开始的 2,000 行   强制走索引结果 1 2 3 4 5 6 7 8  SELECT * FROM employees force index (idx_name_age_position) WHERE name \u0026gt; \u0026#39;LiLei\u0026#39;; vitah\u0026gt; SELECT * FROM employees force index (idx_name_age_position) WHERE name \u0026gt; \u0026#39;LiLei\u0026#39; [2022-03-26 22:11:48] 在 140 ms (execution: 16 ms, fetching: 124 ms) 内检索到从 1 开始的 2,000 行   可以看到，强制走索引的效率甚至还不如不走索引的执行效果。\n如何优化？ 我们可以使用覆盖索引来优化。什么是覆盖索引？\n 创建一个索引，该索引包含查询中用到的所有字段，称为“覆盖索引”。 使用覆盖索引，MySQL 只需要通过索引就可以查找和返回查询所需要的数据，而不必在使用索引处理数据之后再进行回表操作。 覆盖索引可以一次性完成查询工作，有效减少IO，提高查询效率。\n 1 2 3 4 5 6  EXPLAINSELECTname,age,positionFROMemployeesWHEREname\u0026gt;\u0026#39;LiLei\u0026#39;ANDage=22ANDposition=\u0026#39;mana er\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 49954, \u0026#34;filtered\u0026#34;: 1, \u0026#34;Extra\u0026#34;: \u0026#34;Using where; Using index\u0026#34; } ]   in和or查询 是否会走索引？ 在数据量比较大的情况下会走索引，在表记录不多的情况会选择全表扫描。\n大数据量情况 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREnamein(\u0026#39;LiLei\u0026#39;,\u0026#39;HanMeimei\u0026#39;,\u0026#39;Lucy\u0026#39;)ANDage=22ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   可以看到，key 为 idx_name_age_position 用到了索引。\n小数据量情况 复制同样结构的表，往里面插入3条数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  CREATE TABLE `employees_copy` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(24) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;姓名\u0026#39;, `age` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;年龄\u0026#39;, `position` varchar(20) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;职位\u0026#39;, `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;入职时间\u0026#39;, PRIMARY KEY (`id`), KEY `idx_name_age_position` (`name`, `age`, `position`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 100004 DEFAULT CHARSET = utf8 COMMENT =\u0026#39;员工记录表\u0026#39; NSERT INTO employees_copy(name, age, position, hire_time) VALUES (\u0026#39;LiLei\u0026#39;, 22, \u0026#39;manager\u0026#39;, NOW()); INSERT INTO employees_copy(name, age, position, hire_time) VALUES (\u0026#39;HanMeimei\u0026#39;, 23, \u0026#39;dev\u0026#39;, NOW()); INSERT INTO employees_copy(name, age, position, hire_time) VALUES (\u0026#39;Lucy\u0026#39;, 23, \u0026#39;dev\u0026#39;, NOW());   查询语句：\n1 2 3 4 5 6  EXPLAINSELECT*FROMemployees_copyWHEREnamein(\u0026#39;LiLei\u0026#39;,\u0026#39;HanMeimei\u0026#39;,\u0026#39;Lucy\u0026#39;)ANDage=22ANDposition=\u0026#39;manager\u0026#39;;  执行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees_copy\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   type 为 ALL，走的是全表扫描。\nlike kk% 查询 会不会走索引？ 大数据量查询 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREnamelike\u0026#39;LiLei%\u0026#39;ANDage=22ANDposition=\u0026#39;manager\u0026#39;;  分析结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 5, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   小数据量查询 1 2 3 4 5 6  EXPLAIN SELECT * FROM employees_copy WHERE name LIKE \u0026#39;LiLei%\u0026#39; AND age = 22 AND position = \u0026#39;manager\u0026#39;;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees_copy\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 33.33, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   所以，like KK% 语句一般情况下都会走索引，为什么呢？这里其实是用到了索引下推优化。\n索引下推 对于辅助的联合索引 (name,age,posisiton)，正常情况按照最左前缀原则，查询语句只会走 name 字段索引， 因为 name 字段过滤完，得到的索引行里的 age 和 position 是无序的，无法很好的利用索引。 在Mysql5.6之前的版本，这个查询只能在联合索引里匹配到名字是 LiLei 开头的索引， 然后拿这些索引对应的主键逐个回表，到主键索引上找出对应记录，再比较 age 和 position 两个字段的值是否符合。\nMysql5.6 引入了索引下推优化，可以在索引遍历过程中，对索引包含的所有字段做判断，过滤掉不符合条件的记录再回表，可以有效的减少回表次数。 使用了索引下推之后，上面那个查询在联合索引里匹配到名字符合的索引之后，同时还会在索引里面过滤 age 和 position 这两个字段， 拿着过滤完剩下的索引的主键ID再回表。索引下推会减少回表次数，对于InnoDB引擎的表索引下推只能用于二级索引， InnoDB的主键索引树叶子节点上保存的是全行数据，所有这个时候索引下推并不会减少查询全行数据的效果。\n范围查找是否会用到索引下推？ 没有。猜测原因：估计应该是Mysql认为范围查找过滤的结果集过大，like kk% 在绝大多数情况下过滤后的结果集小，所以mysql选择给 like kk% 用了索引下推优化， 当然这也不是绝对的，有时 like kk% 也可能不用索引下推。\norder by 与group by case1: order by用到了联合索引的中间字段 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ANDposition=\u0026#39;dev\u0026#39;ORDERBYage;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 10, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   最左前缀法则，中间字段不能断，因此查询用到了 name 索引，从 key_len=74 也能看出。 age 列用在了排序之中，因为 extra 里面没有 using filesort。\ncase2: order by用到了联合索引的最后一个字段 1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ORDERBYposition;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition; Using filesort\u0026#34; } ]   key_len=74，查询使用了 name 索引。由于用了 position 进行排序，跳过了 age，出现了 Using filesort。\ncase3 1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ORDERBYage,position;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   查询只用到了索引 name，age 和 position 用于排序，无 Using filesort。\ncase4 1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ORDERBYposition,age;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition; Using filesort\u0026#34; } ]   和case2 中结果一样。\ncase5 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ANDage=10ORDERBYposition;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;78\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const,const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   与 case4 对比，因为 age 为常量，在排序中被优化，所以索引未颠倒，不会出现 Using filesort。\ncase6 1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ORDERBYageASC,positionDESC;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition; Using filesort\u0026#34; } ]   虽然排序的字段与索引顺序一样，且 order by 默认升序，这里 position desc 变成了降序，导致与索引的排序方式不同， 从而产生了 Using filesort。Mysql8以上版本有降序索引可以支持该查询方式。\ncase7 1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREnameIN(\u0026#39;LiLei\u0026#39;,\u0026#39;Hanmeimei\u0026#39;)ORDERBYage,position;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 2, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition; Using filesort\u0026#34; } ]   对于排序来说，多个相等条件等于范围查询。\ncase8 1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREname\u0026gt;\u0026#39;a\u0026#39;ORDERBYname;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 100269, \u0026#34;filtered\u0026#34;: 50, \u0026#34;Extra\u0026#34;: \u0026#34;Using where; Using filesort\u0026#34; } ]   可以看到，上述查询并不会用到索引。但是可以使用覆盖索引进行优化。\n1 2 3 4 5  EXPLAINSELECTname,age,positionFROMemployeesWHEREname\u0026gt;\u0026#39;a\u0026#39;ORDERBYname;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;74\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 50134, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using where; Using index\u0026#34; } ]   优化总结  mysql支持两种方式的排序 filesort 和 index，Using index 指扫描索引本身完成排序。index效率高，filesort效率低。 order by 满足两种情况会使用 Using index  order by 语句使用索引最左前列 使用 where 子句与 order by 子句条件列组合满足索引最左前列   尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则 如果 order by 的条件不在索引列上，就会产生 Using filesort 能用覆盖索引尽量用覆盖索引 group by 与 order by 很类似，实质是先排序后分组，遵循索引创建顺序的最左前缀法则。对于 group by 的优化如果不需要排序可以加上 order by null禁止排序。注意，where 高于 having，能写在 where 中的限定条件就不要去having 限定了。  Using filesort文件排序原理 filesort 文件排序方式 单路排序 一次性取出满足条件所有字段，然后在 sort buffer 中进行排序；用 trace 工具可以看到 sort_model 信息里面显示 \u0026lt;sort_key, additional_fields\u0026gt; 或者 \u0026lt;sort_key, packed_additional_fields\u0026gt;\n双路排序 又叫回表排序方式。先根据对于条件取出排序字段和可以直接定位行数据的行ID，然后在 sort buffer 中进行排序，排序完成后需要再次取回其他需要的字段；用trace工具可以看到 sort_model 信息里面显示 \u0026lt;sort_key, rowid\u0026gt;\n什么时候用单路排序什么时候用双路排序？ mysql 通过比较系统变量 max_length_for_sort_data(默认1024字节)的大小和需要查询的字段总大小来判断使用哪种排序模式\n 如果字段总长度小于max_length_for_sort_data，使用单路排序 字段总长度大于max_length_for_sort_data，使用双路排序  filesort文件排序示例 单路排序示例 1 2 3 4 5 6 7 8 9  SETSESSIONOPTIMIZER_TRACE=\u0026#39;enabled=on\u0026#39;,END_MARKERS_IN_JSON=ON;SELECT*FROMemployeesWHEREname=\u0026#39;lilei\u0026#39;ORDERBYposition;SELECT*FROMinformation_schema.optimizer_trace;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256  { \u0026#34;steps\u0026#34;: [ { \u0026#34;join_preparation\u0026#34;: { \u0026#34;select#\u0026#34;: 1, \u0026#34;steps\u0026#34;: [ { \u0026#34;expanded_query\u0026#34;: \u0026#34;/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` = \u0026#39;zhuge\u0026#39;) order by `employees`.`position`\u0026#34; } ] /* steps */ } /* join_preparation */ }, { \u0026#34;join_optimization\u0026#34;: { \u0026#34;select#\u0026#34;: 1, \u0026#34;steps\u0026#34;: [ { \u0026#34;condition_processing\u0026#34;: { \u0026#34;condition\u0026#34;: \u0026#34;WHERE\u0026#34;, \u0026#34;original_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34;, \u0026#34;steps\u0026#34;: [ { \u0026#34;transformation\u0026#34;: \u0026#34;equality_propagation\u0026#34;, \u0026#34;resulting_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34; }, { \u0026#34;transformation\u0026#34;: \u0026#34;constant_propagation\u0026#34;, \u0026#34;resulting_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34; }, { \u0026#34;transformation\u0026#34;: \u0026#34;trivial_condition_removal\u0026#34;, \u0026#34;resulting_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34; } ] /* steps */ } /* condition_processing */ }, { \u0026#34;substitute_generated_columns\u0026#34;: { } /* substitute_generated_columns */ }, { \u0026#34;table_dependencies\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;row_may_be_null\u0026#34;: false, \u0026#34;map_bit\u0026#34;: 0, \u0026#34;depends_on_map_bits\u0026#34;: [ ] /* depends_on_map_bits */ } ] /* table_dependencies */ }, { \u0026#34;ref_optimizer_key_uses\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;equals\u0026#34;: \u0026#34;\u0026#39;zhuge\u0026#39;\u0026#34;, \u0026#34;null_rejecting\u0026#34;: false } ] /* ref_optimizer_key_uses */ }, { \u0026#34;rows_estimation\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;range_analysis\u0026#34;: { \u0026#34;table_scan\u0026#34;: { \u0026#34;rows\u0026#34;: 100269, \u0026#34;cost\u0026#34;: 20345 } /* table_scan */, \u0026#34;potential_range_indexes\u0026#34;: [ { \u0026#34;index\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;usable\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;not_applicable\u0026#34; }, { \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;usable\u0026#34;: true, \u0026#34;key_parts\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;position\u0026#34;, \u0026#34;id\u0026#34; ] /* key_parts */ } ] /* potential_range_indexes */, \u0026#34;setup_range_conditions\u0026#34;: [ ] /* setup_range_conditions */, \u0026#34;group_index_range\u0026#34;: { \u0026#34;chosen\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;not_group_by_or_distinct\u0026#34; } /* group_index_range */, \u0026#34;analyzing_range_alternatives\u0026#34;: { \u0026#34;range_scan_alternatives\u0026#34;: [ { \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;ranges\u0026#34;: [ \u0026#34;zhuge \u0026lt;= name \u0026lt;= zhuge\u0026#34; ] /* ranges */, \u0026#34;index_dives_for_eq_ranges\u0026#34;: true, \u0026#34;rowid_ordered\u0026#34;: false, \u0026#34;using_mrr\u0026#34;: false, \u0026#34;index_only\u0026#34;: false, \u0026#34;rows\u0026#34;: 1, \u0026#34;cost\u0026#34;: 2.21, \u0026#34;chosen\u0026#34;: true } ] /* range_scan_alternatives */, \u0026#34;analyzing_roworder_intersect\u0026#34;: { \u0026#34;usable\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;too_few_roworder_scans\u0026#34; } /* analyzing_roworder_intersect */ } /* analyzing_range_alternatives */, \u0026#34;chosen_range_access_summary\u0026#34;: { \u0026#34;range_access_plan\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;range_scan\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;ranges\u0026#34;: [ \u0026#34;zhuge \u0026lt;= name \u0026lt;= zhuge\u0026#34; ] /* ranges */ } /* range_access_plan */, \u0026#34;rows_for_plan\u0026#34;: 1, \u0026#34;cost_for_plan\u0026#34;: 2.21, \u0026#34;chosen\u0026#34;: true } /* chosen_range_access_summary */ } /* range_analysis */ } ] /* rows_estimation */ }, { \u0026#34;considered_execution_plans\u0026#34;: [ { \u0026#34;plan_prefix\u0026#34;: [ ] /* plan_prefix */, \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;best_access_path\u0026#34;: { \u0026#34;considered_access_paths\u0026#34;: [ { \u0026#34;access_type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;cost\u0026#34;: 1.2, \u0026#34;chosen\u0026#34;: true }, { \u0026#34;access_type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;range_details\u0026#34;: { \u0026#34;used_index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34; } /* range_details */, \u0026#34;chosen\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;heuristic_index_cheaper\u0026#34; } ] /* considered_access_paths */ } /* best_access_path */, \u0026#34;condition_filtering_pct\u0026#34;: 100, \u0026#34;rows_for_plan\u0026#34;: 1, \u0026#34;cost_for_plan\u0026#34;: 1.2, \u0026#34;chosen\u0026#34;: true } ] /* considered_execution_plans */ }, { \u0026#34;attaching_conditions_to_tables\u0026#34;: { \u0026#34;original_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34;, \u0026#34;attached_conditions_computation\u0026#34;: [ ] /* attached_conditions_computation */, \u0026#34;attached_conditions_summary\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;attached\u0026#34;: null } ] /* attached_conditions_summary */ } /* attaching_conditions_to_tables */ }, { \u0026#34;clause_processing\u0026#34;: { \u0026#34;clause\u0026#34;: \u0026#34;ORDER BY\u0026#34;, \u0026#34;original_clause\u0026#34;: \u0026#34;`employees`.`position`\u0026#34;, \u0026#34;items\u0026#34;: [ { \u0026#34;item\u0026#34;: \u0026#34;`employees`.`position`\u0026#34; } ] /* items */, \u0026#34;resulting_clause_is_simple\u0026#34;: true, \u0026#34;resulting_clause\u0026#34;: \u0026#34;`employees`.`position`\u0026#34; } /* clause_processing */ }, { \u0026#34;added_back_ref_condition\u0026#34;: \u0026#34;((`employees`.`name` \u0026lt;=\u0026gt; \u0026#39;zhuge\u0026#39;))\u0026#34; }, { \u0026#34;reconsidering_access_paths_for_index_ordering\u0026#34;: { \u0026#34;clause\u0026#34;: \u0026#34;ORDER BY\u0026#34;, \u0026#34;steps\u0026#34;: [ ] /* steps */, \u0026#34;index_order_summary\u0026#34;: { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;index_provides_order\u0026#34;: false, \u0026#34;order_direction\u0026#34;: \u0026#34;undefined\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;plan_changed\u0026#34;: false } /* index_order_summary */ } /* reconsidering_access_paths_for_index_ordering */ }, { \u0026#34;refine_plan\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;pushed_index_condition\u0026#34;: \u0026#34;(`employees`.`name` \u0026lt;=\u0026gt; \u0026#39;zhuge\u0026#39;)\u0026#34;, \u0026#34;table_condition_attached\u0026#34;: null } ] /* refine_plan */ } ] /* steps */ } /* join_optimization */ }, { \u0026#34;join_execution\u0026#34;: { \u0026#34;select#\u0026#34;: 1, \u0026#34;steps\u0026#34;: [ { \u0026#34;filesort_information\u0026#34;: [ { \u0026#34;direction\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;position\u0026#34; } ] /* filesort_information */, \u0026#34;filesort_priority_queue_optimization\u0026#34;: { \u0026#34;usable\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;not applicable (no LIMIT)\u0026#34; } /* filesort_priority_queue_optimization */, \u0026#34;filesort_execution\u0026#34;: [ ] /* filesort_execution */, /* 文件排序信息 */ \u0026#34;filesort_summary\u0026#34;: { /* 预扫描行数 */ \u0026#34;rows\u0026#34;: 0, /* 参与排序的行 */ \u0026#34;examined_rows\u0026#34;: 0, /* 使用临时文件的个数，这个值为0代表全部使用sort_buffer内存排序，否则使用的磁盘文件排序 */ \u0026#34;number_of_tmp_files\u0026#34;: 0, /* 排序缓存的大小，单位Byte */ \u0026#34;sort_buffer_size\u0026#34;: 262056, /* 排序方式，这里是单路排序 */ \u0026#34;sort_mode\u0026#34;: \u0026#34;\u0026lt;sort_key, packed_additional_fields\u0026gt;\u0026#34; } /* filesort_summary */ } ] /* steps */ } /* join_execution */ } ] /* steps */ }   单路排序过程\n 从索引name找到第一个满足条件name=\u0026lsquo;lilei\u0026rsquo; 的主键ID 根据主键ID取出整行所有字段的值，存sort_buffer中 从索引name找到下一个满足条件的主键ID 重复2，3步骤知道条件不满足 name=\u0026lsquo;lilei\u0026rsquo; 对sort_buffer中的数据按照字段position进行排序 返回结果给客户端  双路排序示例 1 2 3 4 5 6 7 8 9  SETMAX_LENGTH_FOR_SORT_DATA=10;SELECT*FROMemployeesWHEREname=\u0026#39;zhuge\u0026#39;ORDERBYposition;SELECT*FROMinformation_schema.optimizer_trace;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249  { \u0026#34;steps\u0026#34;: [ { \u0026#34;join_preparation\u0026#34;: { \u0026#34;select#\u0026#34;: 1, \u0026#34;steps\u0026#34;: [ { \u0026#34;expanded_query\u0026#34;: \u0026#34;/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` = \u0026#39;zhuge\u0026#39;) order by `employees`.`position`\u0026#34; } ] /* steps */ } /* join_preparation */ }, { \u0026#34;join_optimization\u0026#34;: { \u0026#34;select#\u0026#34;: 1, \u0026#34;steps\u0026#34;: [ { \u0026#34;condition_processing\u0026#34;: { \u0026#34;condition\u0026#34;: \u0026#34;WHERE\u0026#34;, \u0026#34;original_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34;, \u0026#34;steps\u0026#34;: [ { \u0026#34;transformation\u0026#34;: \u0026#34;equality_propagation\u0026#34;, \u0026#34;resulting_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34; }, { \u0026#34;transformation\u0026#34;: \u0026#34;constant_propagation\u0026#34;, \u0026#34;resulting_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34; }, { \u0026#34;transformation\u0026#34;: \u0026#34;trivial_condition_removal\u0026#34;, \u0026#34;resulting_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34; } ] /* steps */ } /* condition_processing */ }, { \u0026#34;substitute_generated_columns\u0026#34;: { } /* substitute_generated_columns */ }, { \u0026#34;table_dependencies\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;row_may_be_null\u0026#34;: false, \u0026#34;map_bit\u0026#34;: 0, \u0026#34;depends_on_map_bits\u0026#34;: [ ] /* depends_on_map_bits */ } ] /* table_dependencies */ }, { \u0026#34;ref_optimizer_key_uses\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;equals\u0026#34;: \u0026#34;\u0026#39;zhuge\u0026#39;\u0026#34;, \u0026#34;null_rejecting\u0026#34;: false } ] /* ref_optimizer_key_uses */ }, { \u0026#34;rows_estimation\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;range_analysis\u0026#34;: { \u0026#34;table_scan\u0026#34;: { \u0026#34;rows\u0026#34;: 100269, \u0026#34;cost\u0026#34;: 20345 } /* table_scan */, \u0026#34;potential_range_indexes\u0026#34;: [ { \u0026#34;index\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;usable\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;not_applicable\u0026#34; }, { \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;usable\u0026#34;: true, \u0026#34;key_parts\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;position\u0026#34;, \u0026#34;id\u0026#34; ] /* key_parts */ } ] /* potential_range_indexes */, \u0026#34;setup_range_conditions\u0026#34;: [ ] /* setup_range_conditions */, \u0026#34;group_index_range\u0026#34;: { \u0026#34;chosen\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;not_group_by_or_distinct\u0026#34; } /* group_index_range */, \u0026#34;analyzing_range_alternatives\u0026#34;: { \u0026#34;range_scan_alternatives\u0026#34;: [ { \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;ranges\u0026#34;: [ \u0026#34;zhuge \u0026lt;= name \u0026lt;= zhuge\u0026#34; ] /* ranges */, \u0026#34;index_dives_for_eq_ranges\u0026#34;: true, \u0026#34;rowid_ordered\u0026#34;: false, \u0026#34;using_mrr\u0026#34;: false, \u0026#34;index_only\u0026#34;: false, \u0026#34;rows\u0026#34;: 1, \u0026#34;cost\u0026#34;: 2.21, \u0026#34;chosen\u0026#34;: true } ] /* range_scan_alternatives */, \u0026#34;analyzing_roworder_intersect\u0026#34;: { \u0026#34;usable\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;too_few_roworder_scans\u0026#34; } /* analyzing_roworder_intersect */ } /* analyzing_range_alternatives */, \u0026#34;chosen_range_access_summary\u0026#34;: { \u0026#34;range_access_plan\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;range_scan\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;ranges\u0026#34;: [ \u0026#34;zhuge \u0026lt;= name \u0026lt;= zhuge\u0026#34; ] /* ranges */ } /* range_access_plan */, \u0026#34;rows_for_plan\u0026#34;: 1, \u0026#34;cost_for_plan\u0026#34;: 2.21, \u0026#34;chosen\u0026#34;: true } /* chosen_range_access_summary */ } /* range_analysis */ } ] /* rows_estimation */ }, { \u0026#34;considered_execution_plans\u0026#34;: [ { \u0026#34;plan_prefix\u0026#34;: [ ] /* plan_prefix */, \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;best_access_path\u0026#34;: { \u0026#34;considered_access_paths\u0026#34;: [ { \u0026#34;access_type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;cost\u0026#34;: 1.2, \u0026#34;chosen\u0026#34;: true }, { \u0026#34;access_type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;range_details\u0026#34;: { \u0026#34;used_index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34; } /* range_details */, \u0026#34;chosen\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;heuristic_index_cheaper\u0026#34; } ] /* considered_access_paths */ } /* best_access_path */, \u0026#34;condition_filtering_pct\u0026#34;: 100, \u0026#34;rows_for_plan\u0026#34;: 1, \u0026#34;cost_for_plan\u0026#34;: 1.2, \u0026#34;chosen\u0026#34;: true } ] /* considered_execution_plans */ }, { \u0026#34;attaching_conditions_to_tables\u0026#34;: { \u0026#34;original_condition\u0026#34;: \u0026#34;(`employees`.`name` = \u0026#39;zhuge\u0026#39;)\u0026#34;, \u0026#34;attached_conditions_computation\u0026#34;: [ ] /* attached_conditions_computation */, \u0026#34;attached_conditions_summary\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;attached\u0026#34;: null } ] /* attached_conditions_summary */ } /* attaching_conditions_to_tables */ }, { \u0026#34;clause_processing\u0026#34;: { \u0026#34;clause\u0026#34;: \u0026#34;ORDER BY\u0026#34;, \u0026#34;original_clause\u0026#34;: \u0026#34;`employees`.`position`\u0026#34;, \u0026#34;items\u0026#34;: [ { \u0026#34;item\u0026#34;: \u0026#34;`employees`.`position`\u0026#34; } ] /* items */, \u0026#34;resulting_clause_is_simple\u0026#34;: true, \u0026#34;resulting_clause\u0026#34;: \u0026#34;`employees`.`position`\u0026#34; } /* clause_processing */ }, { \u0026#34;added_back_ref_condition\u0026#34;: \u0026#34;((`employees`.`name` \u0026lt;=\u0026gt; \u0026#39;zhuge\u0026#39;))\u0026#34; }, { \u0026#34;reconsidering_access_paths_for_index_ordering\u0026#34;: { \u0026#34;clause\u0026#34;: \u0026#34;ORDER BY\u0026#34;, \u0026#34;steps\u0026#34;: [ ] /* steps */, \u0026#34;index_order_summary\u0026#34;: { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;index_provides_order\u0026#34;: false, \u0026#34;order_direction\u0026#34;: \u0026#34;undefined\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;plan_changed\u0026#34;: false } /* index_order_summary */ } /* reconsidering_access_paths_for_index_ordering */ }, { \u0026#34;refine_plan\u0026#34;: [ { \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;pushed_index_condition\u0026#34;: \u0026#34;(`employees`.`name` \u0026lt;=\u0026gt; \u0026#39;zhuge\u0026#39;)\u0026#34;, \u0026#34;table_condition_attached\u0026#34;: null } ] /* refine_plan */ } ] /* steps */ } /* join_optimization */ }, { \u0026#34;join_execution\u0026#34;: { \u0026#34;select#\u0026#34;: 1, \u0026#34;steps\u0026#34;: [ { \u0026#34;filesort_information\u0026#34;: [ { \u0026#34;direction\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;`employees`\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;position\u0026#34; } ] /* filesort_information */, \u0026#34;filesort_priority_queue_optimization\u0026#34;: { \u0026#34;usable\u0026#34;: false, \u0026#34;cause\u0026#34;: \u0026#34;not applicable (no LIMIT)\u0026#34; } /* filesort_priority_queue_optimization */, \u0026#34;filesort_execution\u0026#34;: [ ] /* filesort_execution */, \u0026#34;filesort_summary\u0026#34;: { \u0026#34;rows\u0026#34;: 0, \u0026#34;examined_rows\u0026#34;: 0, \u0026#34;number_of_tmp_files\u0026#34;: 0, \u0026#34;sort_buffer_size\u0026#34;: 262136, \u0026#34;sort_mode\u0026#34;: \u0026#34;\u0026lt;sort_key, rowid\u0026gt;\u0026#34; } /* filesort_summary */ } ] /* steps */ } /* join_execution */ } ] /* steps */ }   可以看到这里的，sort_mode值为\u0026lt;sort_key, rowid\u0026gt;，这里已经变为双路排序。\n双路排序过程\n 从索引name找到第一个满足条件name=\u0026lsquo;lilei\u0026rsquo; 的主键ID 根据主键ID取出整行，把排序字段position和主键ID这两个字段放到sort_buffer中 从索引name找到下一个满足条件的主键ID 重复2，3步骤知道条件不满足 name=\u0026lsquo;lilei\u0026rsquo; 对sort_buffer中的字段position和主键ID按照字段position进行排序 遍历排序好的ID和字段position，按照主键ID值回到原表中取出所有字段的值返回给客户端  两种排序方式对比 单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键 和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。 如果 MySQL 排序内存 sort_buffer 配置的比较小并且没有条件继续增加了，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在sort_buffer 中一次排序更 多的行，只是需要再根据主键回到原表取数据。 如果 MySQL 排序内存有条件可以配置比较大，可以适当增大max_length_for_sort_data 的值，让优化器 优先选择全字段排序(单路排序)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。 所以，MySQL通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。\n注意，如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增 大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。\n分页查询优化 普通的分页查询 1 2 3 4  EXPLAINSELECT*FROMemployeesLIMIT10000,5;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 100269, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   上述查询从表中取出从10000开始的5行记录。看似只查询了5条记录，实际上条SQL是先读取10005条记录，然后抛弃前10000条记录读到后面10条想要的记录。因此要查询一张大表比较靠后的数据，执行效率是非常低的。\n常见的优化 自增且连续的主键排序的分页查询 当ID都是自增且连续主键排序，可以将上述查询换成:\n1 2 3 4  SELECT*FROMemployeesWHEREid\u0026gt;10000LIMIT5;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 50134, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   缺点：\n 在很多场景不实用，因为表中可能某些记录被删，主键不连续导致结果不一致。 如果原来SQL 是order by 非主键的字段，按照这种优化会导致两条SQL结果不一致。  非主键字段排序的分页查询 1 2 3 4 5  EXPLAINSELECT*FROMemployeesORDERBYnameLIMIT90000,5  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 100269, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using filesort\u0026#34; } ]   查询并没有使用name字段的索引。具体原因是扫描整个索引并查找到没有索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引。\n那么如何优化呢？ 关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，再根据主键查到对应的记录，SQL改写如下：\n1 2 3 4  EXPLAINSELECT*FROMemployeeseINNERJOIN(SELECTidFROMemployeesORDERBYnameLIMIT90000,5)edONe.id=ed.id  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;\u0026lt;derived2\u0026gt;\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 90005, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null }, { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;e\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;eq_ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;ed.id\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null }, { \u0026#34;id\u0026#34;: 2, \u0026#34;select_type\u0026#34;: \u0026#34;DERIVED\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;index\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 90005, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   ","date":"2022-04-12T00:00:00Z","permalink":"https://www.vitahlin.com/posts/mysql-indexing-optimization-practices/","title":"Mysql索引优化实践"},{"content":"示例表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  DROPTABLEIFEXISTSemployees;CREATETABLE`employees`(`id`int(11)NOTNULLAUTO_INCREMENT,`name`varchar(24)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;姓名\u0026#39;,`age`int(11)NOTNULLDEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;年龄\u0026#39;,`position`varchar(20)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;职位\u0026#39;,`hire_time`timestampNOTNULLDEFAULTCURRENT_TIMESTAMPCOMMENT\u0026#39;入职时间\u0026#39;,PRIMARYKEY(`id`),KEY`idx_name_age_position`(`name`,`age`,`position`)USINGBTREE)ENGINE=InnoDBAUTO_INCREMENT=4DEFAULTCHARSET=utf8COMMENT=\u0026#39;员工记录表\u0026#39;;INSERTINTOemployees(name,age,position,hire_time)VALUES(\u0026#39;LiLei\u0026#39;,22,\u0026#39;manager\u0026#39;,NOW());INSERTINTOemployees(name,age,position,hire_time)VALUES(\u0026#39;HanMeimei\u0026#39;,23,\u0026#39;dev\u0026#39;,NOW());INSERTINTOemployees(name,age,position,hire_time)VALUES(\u0026#39;Lucy\u0026#39;,23,\u0026#39;dev\u0026#39;,NOW());  索引优化规则 1. 最左匹配原则 如果索引了多列，要遵守最左匹配原则。查询从索引最左前列开始并且不跳过索引中间的列。\n2. 不在索引列上做操作 不在索引列上做任何操作(计算、函数、类型转换(自动/手动))，会导致索引失效而转向全表扫描。\n1  EXPLAINSELECT*FROMemployeesWHEREleft(name,3)=\u0026#39;LiLei\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99909, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   3. 存储引擎不能使用索引中范围条件右边的列 走索引示例 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ANDage=22ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const,const,const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   不走索引示例 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ANDage\u0026gt;22ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;78\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 10, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   4. 尽量使用覆盖索引，减少 select * 覆盖索引示例 1 2 3 4 5 6  EXPLAINSELECTname,ageFROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ANDage=23ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const,const,const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   非覆盖索引select * 1 2 3 4 5 6  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ANDage=23ANDposition=\u0026#39;manager\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const,const,const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   5. 使用!=, \u0026lt;\u0026gt;, not in, not exist的时候不会用到索引 \u0026lt; 小于、 \u0026gt; 大于、 \u0026lt;=、\u0026gt;= 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引\n1 2 3 4  EXPLAINSELECT*FROMemployeesWHEREname!=\u0026#39;LiLei\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99909, \u0026#34;filtered\u0026#34;: 50, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   6. is null, is not null一般情况下也无法用到索引 1 2 3 4  EXPLAINSELECT*FROMemployeesWHEREnameISNULL  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: null, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: null, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: null, \u0026#34;filtered\u0026#34;: null, \u0026#34;Extra\u0026#34;: \u0026#34;Impossible WHERE\u0026#34; } ]   7. like以通配符开头(\u0026rsquo;$abc\u0026hellip;\u0026rsquo;)索引会失效 1 2 3 4  EXPLAINSELECT*FROMemployeesWHEREnameLIKE\u0026#39;%Lei\u0026#39;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99909, \u0026#34;filtered\u0026#34;: 11.11, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   如何解决 like '%abc%'索引失效问题？ 覆盖索引 使用覆盖索引，查询字段必须是建立覆盖索引字段，例如\n1 2 3 4  EXPLAINSELECTname,age,positionFROMemployeesWHEREnameLIKE\u0026#39;%lei%\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;index\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;140\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99909, \u0026#34;filtered\u0026#34;: 11.11, \u0026#34;Extra\u0026#34;: \u0026#34;Using where; Using index\u0026#34; } ]   搜索引擎 如果不能使用覆盖索引，则可借助搜索引擎，如ES。\n8. 字符串不加单引号会导致索引失效 1 2 3 4  EXPLAINSELECT*FROMemployeesWHEREname=1000;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99909, \u0026#34;filtered\u0026#34;: 10, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   这其实是类型转换的问题\n9. 少用or或者in 少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。例如：\n1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREname=\u0026#39;LiLei\u0026#39;ORname=\u0026#39;HanMeimei\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name_age_position\u0026#34;, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 66.67, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   10. 范围查询 是否会走索引？ 先给年龄字段添加单值索引\n1 2  ALTERTABLE`employees`ADDINDEX`idx_age`(`age`)USINGBTREE;  1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREage\u0026gt;=1ANDage\u0026lt;=2000;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 99909, \u0026#34;filtered\u0026#34;: 11.11, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。\n如何优化范围查询 优化方法：将大的范围拆分成多个小范围。\n1 2 3 4 5  EXPLAINSELECT*FROMemployeesWHEREage\u0026gt;=1001ANDage\u0026lt;=2000;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;employees\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_age\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_age\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1000, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   11. 不要在小基数字段上建立索引 索引基数是指这个字段在表里总共有多少个不同的值，比如性别字段，值不是男就是女，该字段基数就是2。 如果对这种小基数字段建立索引的话，还不如全表扫描来，因为你的索引树里面就包含男和女两种值，根本没办法快速的二分查找，那用索引就没有意义了。 一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，才能发挥出B+树快速二分查找的优势。\n12. 长字符串可以采用前缀索引 尽量对字段类型比较小的列设计索引，比如说 tinyint之类的，因为字段类型比较小的话，占用磁盘空间也会比较小。那么当我们需要对 varhcar(255) 这种字段建立索引怎么办？ 我们可以针对这个字段对前20个字符建立索引，就是说把这个字段里对每个值对前20个字符放在索引树里，如 index(name(20), age, position)。 此时在where条件搜索的时候，如果是根据name字段来搜索，就会先到索引树里根据name字段的前20个字符去搜索，定位到前20个字符的前缀匹配的部分数据之后，再回到聚簇索引提前出来完整的name字段值进行比对。 但是如果要是order by name，那么此时name在索引树里面仅仅包含前20个字符，所以这个排序是没法用上索引的，group by也是同理。\n13. where与order by冲突时优先where where与order by出现索引设计冲突时，到底是根据where去设计，还是针对order by去设计索引？ 一般都是让where条件去使用索引来快速筛选一部分指定顺序，接着再进行排序。 大多数情况基于索引进行where筛选可以更快速度筛选你要的少部分数据，然后做排序的成本会小很多。\n14. 基于慢查询sql做优化 什么是慢查询？\n MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。 具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。 long_query_time的默认值为10，意思是记录运行10秒以上的语句。 默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。 当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。\n 索引使用总结 假设索引 index(a,b,c)\n   where 语句 索引是否被使用     where a=3 有，使用到了a   where a=3 and b=5 有，使用到了a, b   where a=3 and b=4 and c=5 有，使用到了a, b, c   where b=3 没有   where b=3 and c=4 没有   where c=4 没有   where a=3 and c=5 有，但只使用了a   where a=3 and b\u0026gt;4 and c=5 有，使用了a,b，c不能用在范围之后，b之后断了   where a=3 and b like \u0026lsquo;kk%\u0026rsquo; and c=4 有，使用到了a,b,c   where a=3 and b like \u0026lsquo;%kk\u0026rsquo; and c=4 有，只用到了a   where a=3 and b like \u0026lsquo;%kk%\u0026rsquo; and c=4 有，只用到了a   where a=3 and b like \u0026lsquo;k%kk%\u0026rsquo; and c=4 有，使用到了a,b,c    like 'kk%'相当于等于常量，%kk 和 %kk% 相当于范围。\n","date":"2022-04-10T00:00:00Z","permalink":"https://www.vitahlin.com/posts/mysql-indexing-optimization-rules/","title":"Mysql索引优化规则"},{"content":"示例表和数据SQL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  DROPTABLEIFEXISTS`actor`;CREATETABLE`actor`(`id`int(11)NOTNULL,`name`varchar(45)DEFAULTNULL,`update_time`datetimeDEFAULTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=utf8;INSERTINTO`actor`(`id`,`name`,`update_time`)VALUES(1,\u0026#39;a\u0026#39;,\u0026#39;2017-12-29 10:27:18\u0026#39;),(2,\u0026#39;b\u0026#39;,\u0026#39;2017-12-29 15:27:18\u0026#39;),(3,\u0026#39;c\u0026#39;,\u0026#39;2017-12-29 15:27:18\u0026#39;);DROPTABLEIFEXISTS`film`;CREATETABLE`film`(`id`int(11)NOTNULLAUTO_INCREMENT,`name`varchar(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`idx_name`(`name`))ENGINE=InnoDBDEFAULTCHARSET=utf8;INSERTINTO`film`(`id`,`name`)VALUES(3,\u0026#39;film0\u0026#39;),(1,\u0026#39;film1\u0026#39;),(2,\u0026#39;film2\u0026#39;);DROPTABLEIFEXISTS`film_actor`;CREATETABLE`film_actor`(`id`int(11)NOTNULL,`film_id`int(11)NOTNULL,`actor_id`int(11)NOTNULL,`remark`varchar(255)DEFAULTNULL,PRIMARYKEY(`id`),KEY`idx_film_actor_id`(`film_id`,`actor_id`))ENGINE=InnoDBDEFAULTCHARSET=utf8;INSERTINTO`film_actor`(`id`,`film_id`,`actor_id`)VALUES(1,1,1),(2,1,2),(3,2,1);  id列 1  explainselect*fromfilmwhereid=1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   其中，id 的编号就是 select 的序列号，有几个 select 就有几个 id，并且 id 的顺序是按 select 出现的顺序增长的，id 越大执行优先级越高，id 相同从上往下执行，id 为 NULL 最后执行。\nselect_type列 select_type 表示对应行是简单还是复杂的查询。\nsimple 简单查询，查询不包含子查询和 union\n1 2 3 4  EXPLAINSELECT*FROMfilmWHEREid=1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   primary, subquery, derived  primary，复杂查询中最外层的 select subquery，包含在 select 中的子查询(不在 from 子句中) derived，包含在 from 子句中的子查询。Mysql 会将结果存放在一个临时表中，也称为派生表。  用下面这个例子来了解 primary、subquery 和 derived 类型\n1 2 3 4 5  #关闭mysql5.7新特性对衍生表的合并优化SETSESSIONoptimizer_switch=\u0026#39;derived_merge=off\u0026#39;;EXPLAINSELECT(SELECT1FROMactorWHEREid=1)FROM(SELECT*FROMfilmWHEREid=1)der;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;\u0026lt;derived3\u0026gt;\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null }, { \u0026#34;id\u0026#34;: 3, \u0026#34;select_type\u0026#34;: \u0026#34;DERIVED\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null }, { \u0026#34;id\u0026#34;: 2, \u0026#34;select_type\u0026#34;: \u0026#34;SUBQUERY\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; }   其中，可以看到 id 最大值为3，表示有3个 select 语句，id=3 的查询对应的子查询是 (select * from film where id = 1) 部分，id=2 对应的是 (select 1 from actor where id = 1) 语句，id=1 则是最外层的select。\nunion 在 union 中的第二个和随后的 select。\n1 2 3 4  EXPLAINSELECT1UNIONALLSELECT1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;table\u0026#34;: null, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: null, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: null, \u0026#34;filtered\u0026#34;: null, \u0026#34;Extra\u0026#34;: \u0026#34;No tables used\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;select_type\u0026#34;: \u0026#34;UNION\u0026#34;, \u0026#34;table\u0026#34;: null, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: null, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: null, \u0026#34;filtered\u0026#34;: null, \u0026#34;Extra\u0026#34;: \u0026#34;No tables used\u0026#34; } ]   table列 这一列表示 explain 的一行正在访问哪个表。它可以是下面值中的一个\n \u0026lt;union M,N\u0026gt; 这一行引用了ID值为M和N的表的联合。M 和 N 表示 union 的 select 行的 id。 \u0026lt;deriven N\u0026gt; 这一行引用了ID值为N的表所派生的表。派生的表可能是一个结果集，比如，FROM 子句中的子查询，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 subquery N 这一行引用了ID值为N的物化字查询的结果。参考：https://dev.mysql.com/doc/refman/5.7/en/subquery-materialization.html  type列 表示关联类型或者访问类型，即 Mysql 决定如何查找表中的行，查找数据行记录的大概范围。 依次从最优到最差分别为：system \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; range \u0026gt; index \u0026gt; ALL，一般来说，要保证查询达到 range 级别，最好达到 ref。\nNULL值 mysql 能够在优化阶段分解查询语句，在执行阶段不需要访问表或者索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。\n1 2 3  EXPLAINSELECTMIN(id)FROMfilm;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: null, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: null, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: null, \u0026#34;filtered\u0026#34;: null, \u0026#34;Extra\u0026#34;: \u0026#34;Select tables optimized away\u0026#34; } ]   const, system mysql 能对查询对某部分进行优化并将其转为一个常量(可以看 show warnings 的结果)。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system 是 const 的特例，表里只有一条元组匹配时为 system**。\n1 2 3 4 5  SETSESSIONoptimizer_switch=\u0026#39;derived_merge=off\u0026#39;;EXPLAINEXTENDEDSELECT*FROM(SELECT*FROMfilmWHEREid=1)tmp;SETSESSIONoptimizer_switch=\u0026#39;derived_merge=on\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;\u0026lt;derived2\u0026gt;\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null }, { \u0026#34;id\u0026#34;: 2, \u0026#34;select_type\u0026#34;: \u0026#34;DERIVED\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   可以看到，id=2 的语句对应 (select * from film where id = 1) 查询，此时比较主键是否相等，类型为 const。id=1 的查询 临时表中只有一条数据，const 转为 system。\neq_ref 主键或者唯一索引的所有部分被连接使用，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。\n1 2 3 4  EXPLAINSELECT*FROMfilm_actorLEFTJOINfilmONfilm_actor.film_id=film.id;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film_actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null }, { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;eq_ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;vitah.film_actor.film_id\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   ref 相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n 简单的 select 查询，name 是普通索引（非唯一索引）  1 2 3 4  EXPLAINSELECT*FROMfilmWHEREname=\u0026#39;film1\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;33\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   关联表查询，例如下面语句，idx_film_actor_id 是表 film_actor 字段 film_id 和 actor_id 的联合索引，这里使用到 film_actor 的左边前缀 film_id 部分。  1 2 3 4  EXPLAINSELECTfilm_idFROMfilmLEFTJOINfilm_actorONfilm.id=film_actor.film_id;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;index\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;33\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; }, { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film_actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;vitah.film.id\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   range 范围扫描通常出现在 in(), between, \u0026gt;, \u0026lt;, ≥ 等操作中，使用一个索引来检索给定范围的行\n1 2 3 4  EXPLAINSELECT*FROMactorWHEREid\u0026gt;1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;PRIMARY\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 2, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   index 扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根结点开始查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为覆盖索引，二级索引一般比较小，所以这种比 ALL 快一些。\n1 2 3  EXPLAINSELECT*FROMfilm;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;index\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;33\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   ALL 即全表扫描，扫描你的聚簇索引的所有叶子节点。通常这种情况就需要增加索引来优化了。\n1 2 3  EXPLAINSELECT*FROMactor;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   possible_keys列 这一列显示查询可能使用哪些索引来查找。 explain 时可能 出现 possible_keys 有列，而 key 显示 NULL 的情况，是因为表中数据不多，mysql 认为索引对此查询帮助不大，选择了全表查询。 如果该列是 NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查询效果。\nkey列 显示 mysql 实际采用哪个索引来优化对该表的访问。 如果没有使用索引，该列值是 NULL。如果想强制 mysql 使用或者忽视 possible_keys 列中的索引，可以使用 force index、ignore index。\n列key_len 显示了在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。\n比如表 film_actor 的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个 int 列组成，并且每个 int 是4字节。通过结果中的 ken_len=4 可推断出查询使用列第一个列：film_id 列来执行索引查找。\n1 2 3 4  EXPLAINSELECT*FROMfilm_actorWHEREfilm_id=2;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film_actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   key_len 的计算规则\n 字符串，char(n) 和 varchar(n)，n 代表字符数，不是字节数，如果是 utf-8，一个数字或者字母占1字节，如果是汉字占3字节。char(n) 存汉字长度为 3n 字节，varchar(n) 存汉字长度为 3n+2 字节，需要额外2字节用来存储字符串长度。 数值类型  tinyint 1字节 smallint 2字节 int 4字节 bigint 8字节   时间类型  date 3字节 timestamp 4字节 datetime 8字节   字段允许为 NULL，需要额外1字节记录是否为 NULL  索引的最大长度是768字节，当字符串过长时，mysql 会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。\nref列 显示了在 key 列记录的索引中，表查找值所用到的列或常量，常见的有 const(常量)，字段名(例如 film.id)\nrows列 mysql 估计要读取并检测的行数，并不是结果集里面的行数，只是一个估计值。\nfiltered列 表示返回结果的行数占需读取行数(列rows值)的百分比，filtered 列的值越大越好，filtered 列的值依赖于统计信息\nExtra列 展示的是额外信息。常见的重要值如下：\n1. Using index：使用覆盖索引 覆盖索引的定义：mysql 执行计划 explain 结果里的 key 列有使用索引，如果 select 后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra 里一般都有 using index。覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其他字段值。\n 覆盖索引  1 2 3 4  EXPLAINSELECTfilm_idFROMfilm_actorWHEREfilm_id=1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film_actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 2, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]    非覆盖索引  1 2 3 4  EXPLAINSELECT*FROMfilm_actorWHEREfilm_id=1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film_actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ref\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;const\u0026#34;, \u0026#34;rows\u0026#34;: 2, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: null } ]   2. Using where 使用 where 语句来处理结果，并且查询的列未被索引覆盖。\n1 2 3 4  EXPLAINSELECT*FROMactorWHEREname=\u0026#39;a\u0026#39;;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 33.33, \u0026#34;Extra\u0026#34;: \u0026#34;Using where\u0026#34; } ]   3. Using index condition 查询的列不完全被索引覆盖，where 条件是一个前导列的范围\n1 2 3 4  EXPLAINSELECT*FROMfilm_actorWHEREfilm_id\u0026gt;1;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film_actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;range\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_film_actor_id\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 1, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index condition\u0026#34; } ]   4. Using temporary mysql 需要创建一张临时表来处理查询。出现这种情况一般需要进行优化，首先想到用索引来优化\n actor.name 没有索引，此时创建来临时表来 distinct  1 2 3  EXPLAINSELECTDISTINCTnameFROMactor;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using temporary\u0026#34; } ]   film.name 建立来 idx_name 索引，此时查询时 extra 是 using index，没有用临时表  1 2 3  EXPLAINSELECTDISTINCTnameFROMfilm;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;index\u0026#34;, \u0026#34;possible_keys\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;33\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   5. Using filesort 将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑用索引来优化。\n 使用外部排序 actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。  1 2 3 4  EXPLAINSELECT*FROMactorORDERBYname;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;actor\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;ALL\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using filesort\u0026#34; } ]    利用索引优化  film.name 建立了 idx_name 索引，此时查询时 extra 是 using index。\n1 2 3 4  EXPLAINSELECT*FROMfilmORDERBYname;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: \u0026#34;film\u0026#34;, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: \u0026#34;index\u0026#34;, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: \u0026#34;idx_name\u0026#34;, \u0026#34;key_len\u0026#34;: \u0026#34;33\u0026#34;, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: 3, \u0026#34;filtered\u0026#34;: 100, \u0026#34;Extra\u0026#34;: \u0026#34;Using index\u0026#34; } ]   6. Select tables optimized away 使用某些聚合函数(比如 max、min)来访问存在索引的某个字段时\n1 2 3  EXPLAINSELECTMIN(id)FROMfilm;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [ { \u0026#34;id\u0026#34;: 1, \u0026#34;select_type\u0026#34;: \u0026#34;SIMPLE\u0026#34;, \u0026#34;table\u0026#34;: null, \u0026#34;partitions\u0026#34;: null, \u0026#34;type\u0026#34;: null, \u0026#34;possible_keys\u0026#34;: null, \u0026#34;key\u0026#34;: null, \u0026#34;key_len\u0026#34;: null, \u0026#34;ref\u0026#34;: null, \u0026#34;rows\u0026#34;: null, \u0026#34;filtered\u0026#34;: null, \u0026#34;Extra\u0026#34;: \u0026#34;Select tables optimized away\u0026#34; } ]   ","date":"2022-04-01T00:00:00Z","permalink":"https://www.vitahlin.com/posts/instruction-of-mysql-explain/","title":"Mysql explain命令介绍"},{"content":"安装 rustup 使用 rustup 安装 rust ，安装 rustup:\n1  curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh   在 Rust 开发环境中，所有工具都安装在 ~/.cargo/bin 目录中，您可以在这里找到包括 rustc、cargo 和 rustup 在内的 Rust 工具链。\n查看 rust 版本 1  rustc --version   卸载 1  rustup self uninstall   升级 1  rustup update   ","date":"2020-09-09T00:00:00Z","permalink":"https://www.vitahlin.com/posts/install-and-upgrade-rust/","title":"rust安装和升级"}]