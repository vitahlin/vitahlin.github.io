[["Spring源码5-Bean生命周期之BeanDefinition生成","2023年01月01日","/2023/01/spring-generate-beandefinition-analyse/"," 前言 Spring 最重要的功能就是帮助程序员创建对象（也就是IOC），而启动 Spring 就是为创建 Bean 对象做准备，所以我们先明白 Spring 到底是怎么去创建 Bean 的，也就是先弄明白 Bean 的生命周期。 Bean的生命周期就是指：在Spring中，一个Bean是如何生成的，如何销毁的。 Spring 在真正去实例化一个 bean 的时候是根据对应的 BeanDefinition 去处理的，所以首先就是要知道 BeanDefinition 是怎么生成的，这个流程也就是 Bean 的扫描流程。 Spring自动扫描注解方式 Spring 容器加载方式主要有以下3种： xml配置文件方式 ClassPathXmlApplicationContext 扫描注解方式 AnnotationConfigApplicationContext 本地配置文件 FileSystemXmlApplicationContext 我们平常使用 Spring可以通过 注解可以声明自动注入要扫描的包，Spring 会将该包下所有加了 注解的 bean 扫描到 Spring 容器中，也可以 通过 xml 文件来配置要扫描的 Bean，不过现在 SpringBoot 一般都是用 注解的方式，所以这里主要介绍自动扫描注解的流程。 Bean扫描流程分析 之前提过，Spring 中的 “Hello world” 如下： 上述几行代码实现了 bean 的扫描和实例化。 首先就是容器的初始化，即： 容器初始化 来看类 AnnotationConfigApplicationContext 的初始化，类 AnnotationConfigApplicationContext 源码如下： 一开始，会执行带参数的构造函数，然后调用无参构造函数。StartupStep 是用来统计耗时的，这里不做具体分析。 这里用于传入指定 bean 的类的时候使用，会直接进行 BeanDefinition 的注册。注意这里传入的是 this 参数。 实际上，不管是直接指定 bean 的类进行注册还是扫描注册，都是注册到类 DefaultListableBeanFactory 的 参数上，参数类型为 而 DefaultListableBeanFactory 是 this 的父类 GenericApplicationContext 进行初始化的，因为在 Java 中子类初始化时会先初始化父类。 这里则是处理对配置类的注册过程， bean 的扫描和生成都是在 方法中执行，因为这里我们先了解 bean 的扫描流程，所以先着重分析 方法的逻辑。 方法源码： 这里要重点关注2个步骤 1. 2. 其中 方法处理对 bean 的扫描， 方法处理对非懒加载单例 bean 的实例化。 方法处理了 bean 的扫描过程，实际上它会调用 方法来完成扫描，我们先来看 方法的处理逻辑。 核心扫描方法ClassPathBeanDefinitionScanner#scan 源码如下： 可以看到 方法比较简单，传进来包路径作为参数，调用了 方法来完成扫描处理，值得说明的是 Spring 源码中都是类似的命名风格，doXXX 表示具体处理什么。 是一个扫描器，这里 是一个接口 ，运行的时候实际的值其实就是 。但是这里扫描器只需要完成注册 就可以了，所以没必要用 ，更符合单一职责。 接下来来看 方法的源码： 即指定的扫描路径。 这个方法就是最核心的扫描逻辑。 : 这里会判断我们是否有定义组件索引，来执行不同扫描逻辑。 有索引的扫描流程 这个方法会去判断 是否有值，这个就是我们配置的 bean 索引，它加载的是 中的信息，内容格式形如： 配置之后，就会加载这里的 Bean 组件，不去做路径下的全部扫描。对于项目过于庞大，扫描耗费时间的情况，可以考虑这种方案。一般情况下都走默认的扫描流程。 默认的扫描流程scanCandidateComponents 接着来看默认的扫描流程 ： 其中 方法就是扫描的核心流程， 构建扫描路径 这里，传入包路径就是字符串，先构造对应的包路径： 这里可以加个print语句来查看最终的路径是什么： 执行结果： 这里的处理逻辑是包名前面加上 前缀，后面加上 ，同时把包名中的 替换成 ，得到搜索路径，最终要匹配查找的是包路径下的 class 文件，包下面可能还有其他文件，但是这里就不管了。 获取包路径下的资源 拿到对应的包路径后，Spring 就用本身的 resource 工具去获取该路径下的资源文件，找出来的其实就是 class 文件的 file 对象。调试信息如下： 可以看到，这里的 Rescource 就是一个个 class 文件的文件对象，接下来就是遍历获取到的 Resource 资源，逐个处理了。 获取类对应的元数据 则是根据 获取类对应的元数据。 什么是元数据？ Metadata is simply data about data. It means it is a description and context of the data. It helps to organize, find and understand data。 上面介绍的大概意思是：元数据是关于数据的数据，元数据是数据的描述和上下文，它有助于组织，查找，理解和使用数据。 Spring 对 MetadataReader 的描述为: Simple facade for accessing class metadata,as read by an ASM. 大意是通过 ASM 读取 class IO 流资源组装访问元数据的门面接口。反正，这里通过 MetadataReader 我们就能拿到类的信息，比如类的名字，类的注解信息等。这里使用了 ASM 技术。 判断是否是@Component组件 拿到类的元信息后，就需要判断这个类是不是一个 bean。我们可能定义了一个类，但是这个类并不是我们需要的 Bean，那么这里是怎么处理的呢？ @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component 大概意思是 是任何Spring管理的组件的通用原型。 、 和 是派生自 。 源码： 这里并不是直接判断类上是否存在 注解，而是去判断类的排除过滤器和包含过滤器： 首先我这个类和任意一个排除过滤器匹配了，那么我就排除这个类； 如果排除过滤器符合，那么继续判断包含过滤器。即如果要成为一个 bean，一定要符合某个包含过滤器才行。 那么这里为什么是通过判断包含过滤器而不是判断是否有注解 ？ 实际上，在 Spring 的 scanner 初始化的时候会注册一个默认的包含过滤器，我们回过头来看 初始化的代码， ： 继续跟进方法 ， ： 可以看到方法的第一行即添加了默认的包含过滤器。 我们可以新建一个非bean的类来测试下。 非Bean类测试用例 新建一个类Student，但是不加 注解： 然后开始断点： 图中可以看到，当前 循环处理的是 这个类，然后右键 -\u0026gt; ，得到的结果为 false，即 Spring 不认为 Student 是一个 bean。 所以这里判断包含过滤器即判断类上是否有 注解，如果有那么就是匹配的，即是一个 bean，再判断条件匹配。 构造 BeanDefinition 上一步判断完成后，确认类是一个bean，就会根据元数据开始构造一个 。 跟进 的构造函数 ： 方法处理： 注意这里，一开始我们只是把这个类的名字赋给了BeanDefinition。 这里的 属性为什么是 类型？ 因为在这里，一开始我们只是把 bean 的名字赋给了它，当我需要这个类的时候，就需要对类进行实例化，实例化后我就能把实例化后的类型赋给 beanClass 属性，覆盖掉原先 String 类型的 BeanName。所以这个 beanClass 分两种情况： 一开始的时候是类的名字 后面实例化后一个类的对象。 判断扫描到的类是不是独立的 构造完 后，这里还会继续判断bean的类型，比如是不是抽象类。这里涉及到一个概念，类是否是独立的。 源码注释中是这么说的： Determine whether the underlying class is independent, i.e. whether it is a top-level class or a nested class (static inner class) that can be constructed independently of an enclosing class. 具体来看方法 ： 测试用例 这里涉及到了独立类的概念，新建 接口类： 然后断点查看 的执行结果，如下： 虽然 UserInterface 加了 注解，但是它并不是独立的将会被过滤。这个方法就是用来过滤诸如内部类、抽象类等，即不依赖其他类也能正常被构建。因为后续扫描完成，有一个很重要的步骤是实例化，而那些非静态的内部类、接口、抽象类是不能被实例化的，故这里需排除在外。 反之，对 UserService 的判定： 可以看到，结果为 。 判定类是可以注册 BeanDefinition 的，那么这里就完成了类的扫描，并且生成了对应的 列表。 接下来就就开始逐个遍历扫描得到的 BeanDefinition 集合，根据 BeanDefinition 生成对应的 Bean。 Bean的scope处理 这里是处理 的 属性，默认是单例属性。 BeanDefinition名字生成 处理完 属性后，开始处理 Bean 的名字： 这行代码，处理了 bean 名字的生成，这里会调用 ，根据 源码： 这里分为2部分： 先是判断我们是不是在注解上自定义了bean的名字 如果没有则根据默认规则生成bean名字 判断注解是不是定义了bean名字 方法源码： 获取当前类上的注解，然后 方法判断是否存在注解 ，如果有的话获取它的 值，如果没有注解或者没有 值，则返回 。 生成默认的Bean名称 如果没有找到我们自定义的 beanName，就需要生成一个默认的 beanName， ： 就是根据bean的全路径名字获取类名，比如 得到的 就是 。 这里，重点来看 ： 会判断类名字的第一个字符和第二个字符，如果前2个字符全部大写的话，那么直接返回类名；否则将返回首字符小写的类名字。 比如类， 它的bean名字就是 ，类 它的bean名字则是 。 这里总结下 bean 名字的生成规则： 判断该类上的注解 @Component 的 value 值 若该值存在, 则返回 若该值不存在，则调用方法生成默认名字 - 若类名前两个字符都是大写字符则直接返回， - 否则将第一个字符小写返回 Bean的默认值处理 主要处理一些bean的默认值，比如我们没有设置懒加载选项，就默认设为非懒加载。 判断Bean是否重复 接下来，方法 会判断类是否重复，最终调用的是 ： 兼容的概念是有可能一个类会被扫描多次，这里就是检查如果是有两个同名的，允许它们是同一个类被扫描了多次，如果已经扫描过，那么不重复注册直接跳过。如果不是兼容的类，但是名字一样就会抛出我们平常比较常见的异常内容。 不重复就将扫描得到的bean添加到列表中。到这里就完成了整个 bean 扫描的逻辑，接下来就是根据得到的 集合进行初始化了。 向容器注册扫描得到的BeanDefinition 这个方法调用的是 ： 看其中的 ，它是一个接口 BeanDefinitionRegistry，实际上的实现方法是 ： 其中 这行就是把扫描得到的 BeanDefinition 注册到集合中 这里还会保存一份 beanName 的集合。 至此就完成了Bean 的扫描整个流程，容器中已经有了对应的 ，后续就可以根据 集合进行 bean 的实例化。 总结 上述整个流程就是 bean 生命周期的第一步-BeanDefinition 的生成，流程图如下： Spring Bean扫描流程.png "],["Spring源码4-核心概念介绍","2023年01月01日","/2023/01/introduction-spring-core-concepts/"," 前言 在深入分析 Spring 源码前，需要先了解 Spring 框架中的一些核心概念，防止后续看源码的过程中，遇到不会的概念得单独跳出来学习。 主要介绍以下内容： 什么是Bean BeanDefinition的概念 BeanFactory的概念 比较核心的BeanFactory实现类 FactoryBean是什么 FactoryBean的作用 什么是BeanPostProcessor 什么是bean 什么是 ？我们可以来看下 Spring 的官方文档： In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container. Spring 是面向 Bean 的编程（Bean Oriented Programming, BOP），Bean 在 Spring 中的作用就像 Object 对 OOP 的意义一样，Spring 中没有 Bean 也就没有 Spring 存在的意义。 Spring 提供了 IoC 容器通过配置文件或者注解的方式来管理对象之间的依赖关系。简而言之，** 是由 Spring IoC 容器实例化、组装和管理的对象。** BeanDefinition 用来表示 定义， 中存在很多属性来描述一个 的特点。比如： class，表示 bean 的类型 scope，表示 bean 的作用域，单例或原型等 lazyInit，表示 bean 是否懒加载 initMethodName，表示 bean 初始化时要执行的方法 destoryMethodName，表示 bean 销毁时要执行的方法 \u0026hellip;（等等） 我们可以简单的认为，Spring 在扫描 class 的时候，会根据 class 文件中的注解等信息，给 对象赋值，所以， 是对一个类的描述。那 Spring 在真正去初始化、实例化一个 bean 的时候，直接根据 去初始化就可以，比如，在判断这个 bean 是根据类型注入还是根据名字注入的时候，就直接判断 的属性值即可。 编程式定义Bean 在 Spring 中，我们通常会通过以下几种方式来定义 ： 1. 2. 3. ( , ) 这些，我们可以称之为**声明式定义 **。 我们还可以编程式定义 ，那就是直接通过 。例如，先定义一个 Bean，但是不添加 等注解： 然后通过 直接定义 这个 Bean： 同理，还可以通过 设置一个 的其他属性，例如： 和声明式事务、编程式事务类似，通过 、 、 等声明式方式所定义的 bean，最终都会被 Spring 解析为对应的 对象，并放入 Spring 容器中。 BeanDefinitionReader 接下来我们来介绍几种在 Spring 源码中所提供的 读取器(BeanDefinitionReader)，这些 在我们使用 Spring 时用的少，但在 Spring 源码中用的多，相当于 Spring 源码的基础设施。 AnnotatedBeanDefinitionReader 可以直接把某个类转换为 。 我们先定义一个 Bean ： 就可以直接通过 把某个类转换为 ： 注意：它能解析的注解是： @Conditional @Scope @Lazy @Primary @DependsOn @Role @Description XmlBeanDefinitionReader 可以用来解析 标签。 例如： ClassPathBeanDefinitionScanner 是扫描器，但是它的作用和 类似，它可以进行扫描，我们可以指定扫描某个路径，让其对扫描到的类进行解析。扫描到的类上如果存在 注解，那么就会把这个类解析为一个 ，比如： BeanFactory 表示 工厂， 会负责创建 ，并且提供获取 的 API。 Bean 工厂的概念是 Spring 作为 IoC 容器的基础。IoC 则将处理事情的责任从应用程序代码转移到框架。 是 的一种，在 Spirng 源码中是这么定义的： 继承了 和 ，而 和 都继承至 ，所以我们可以认为 继承了 。 拥有了 支持的所有功能，而且比 更加强大， 还继承了其他接口，比如 国际化， 事件发布， 获取环境变量等等。 在 Spring 源码实现中，当我们 一个 时，其底层会 一个 出来，当使用 某些方法时，比如 ，底层调用的是 的 方法。 核心的BeanFactory实现类-DefaultListableBeanFactory **在 Spring 源码中，BeanFactory 接口存在一个非常重要的实现类 **。所以我们也可以直接使用 ，而不用使用 的某个实现类。例如： 是非常强大的，支持很多功能，我们可以查看下 的类继承实现结构： DefaultListableBeanFactory类继承实现结构 它实现了很多接口，即拥有很多功能： 支持别名功能，一个名字可以对应多个别名 可以注册、保存、移除、获取某个 Bean工厂，可以根据某个 Bean 的名字、类型、别名获取某个 Bean 对象 可以直接注册、获取某个单例 Bean 它是一个类，实现了 接口中所定义的功能，支持别名功能 在 的基础上，增加了其他功能，可以获取所有 的 ，可以根据某个类型获取对应的 BeanNames，可以根据某个类型获取 类型-对应的Bean 的映射关系 在 的基础上，添加了获取父 的功能 它是一个类，实现了 接口，拥有了直接注册、获取某个单例 Bean 的功能 在 和 的基础上，添加了设置父 、类加载器（可以指定某个类加载器进行类的加载）、设置 Spring EL表达式解析器（表示该 可以解析EL表达式）、设置类型转化服务(表示该 可以进行类型转化)、可以添加 （表示该 支持 Bean 的后置处理器）、可以合并 、可以销毁某个 Bean 等等功能 支持 的功能 直接继承了 ，在 的基础上，支持在创建 Bean 的过程中能对 Bean 进行自动装配 实现了 接口，继承了 ，这个 功能已经很全面，但是不能自动装配和获取 BeanNames。 继承了 ，实现了 、 继承了 ，实现了 ，拥有自动装配的功能 继承了 ，实现了 接口和 接口，所以功能很强大 ApplicationContext 是个接口，实际上也是一个 ，不过比 更加强大，比如： 拥有获取父 的功能 拥有获取 BeanNames 的功能 资源加载器，可以一次性获取多个资源（文件资源等） 可以获取运行时环境 拥有广播时间等功能 拥有国际化功能 我们可以先来看 两个比较重要的实现类： 1. 2. AnnotationConfigApplicationContext 类继承实现结构： AnnotationConfigApplicationContext类继承实现结构 继承了 接口，增加了事件监听器，添加 、设置 、获取 等功能 实现了 接口 继承了 ，实现了 接口，拥有所有 的功能，并且可以注册 ，注意这个类中有一个属性 beanFactory 可以单独注册某个类为 ，可以处理该类上的 注解，可以处理 注解，同时可以扫描 继承了 ，实现了 接口，拥有了以上所有的功能 ClassPathXmlApplicationContext ClassPathXmlApplicationContext类继承结构图 它也是继承了 ，但是相对于 而言，功能没有 强大，比如不能注册 国际化 先定一个 ： 有了这个 Bean，就可以在任意想要国际化的地方使用该 。同时因为 拥有国家化的功能，所以也可以这么用： 资源加载 还拥有资源加载的功能，可以直接利用 获取某个文件的内容： BeanPostProcessor 表示 Bean 的后置处理器，可以定义一个或多个 。 一个 可以在任意一个 的初始化之前和初始化之后去额外做一些用户自定义的逻辑。我们可以通过判断 beanName 来进行针对性处理（针对某个Bean，或者某部分Bean）。 BeanFactoryPostProcessor 表示 Bean 工厂的后置处理器，其实和 类似，只不过 是干涉 的创建过程， 是干涉 的创建过程。 FactoryBean FactoryBean简单介绍 我们可以通过 来干涉 Spring 创建 Bean 的过程，但是如果我们想一个 Bean 完完全全由我们来创造，也是可以的，比如通过 接口。 翻译过来是工厂Bean， 翻译过来是 Bean 工厂， 是 bean 工厂 中的一个 ，只不过这个 和一般的 不一样，它有着自己的特殊之处，特殊在什么地方呢？这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。 接口源码： 接口很简单，就提供了三个方法 、 、 。就是这三个方法却成为了 Spring 中很多功能的基础，搜索整个 Spring 的源码可以找到很多 ，除了 Spring 自身提供的以外，在和一些框架进行集成的时候，同样有 的影子，比如和mybatis集成的时候的 。 FactoryBean示例代码 示例代码： 运行结果： 打印结果很奇怪，通过 获得了 对象，通过 获得了 对象。为什么会这样？ 这就是 的神奇，通俗点讲 是一个工厂bean，它是一种可以生产bean的bean，通过其 方法生产bean。当然不论是 还是 生产的 bean 都是受 Spring 管理的，不然通过 方法是拿不到的。 的作用是生产一个 ，这里有一个疑问 Spring 就是用来生产 和管理 的，为什么还要有 ？ 一般情况下，Spring 通过反射机制利用 的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在 中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个 的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。 接口对于Spring框架来说占用重要的地位，Spring 自身就提供了70多个FactoryBean 的实现。 FactoryBean 的真正目的是让开发者自己去定义那些复杂的 bean 并交给spring管理，如果bean中要初始化很多变量，而且要进行许多操作，那么使用spring的自动装配是很难完成的，所以 Spring 的开发者把这些工作交给了我们。 ExcludeFilter和IncludeFilter 这两个 Filter 是 Spring 扫描中用来过滤的。 是排除过滤器， 是包含过滤器。 在对 bean 的扫描中会判断 注解的过滤器。 MetadataReader、ClassMetadata、AnnotationMetadata 在 Spring 中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数据，所以 Spring 中对类的元数据做了抽象，并提供了一些工具类。 表示类的元数据读取器，默认实现类为 。 "],["Spring源码3-底层核心原理简单介绍","2023年01月01日","/2023/01/introduction-spring-underlying-core-principles/"," Spring中的HelloWorld 任何代码的入门都是 ，同样我们来看下使用 Spring 的入门代码： 中的 main 方法的三行代码，就是我们使用 Spring 的基本方式，可是这几行代码底层到底做了什么？ 比如 第一行会构造一个 对象， 对象该如何理解？调用该构造方法除了实例化一个对象还会做哪些事情？ 第二行代码，会调用 的 方法，会得到一个 对象， 是如何实现的？返回的 对象和我们自己直接 的 对象有区别吗？ 第三行代码比较简单，就是调用 的 方法 光看这三行代码，并不能体现 Spring 的强大之处，但是我们现在可以认为：如果你要用 Spring，你就得这么写。就像要用 Mybatis，就得写各种 Mappe r接口。 接下来，我们就简单介绍一下 Spring 的底层核心原理。 Spring中是如何创建一个对象？ 在Java语言中，肯定是根据某个类来创建一个对象的。 我们再看一下实例化的代码： 当我们调用 时，就会去创建一个对象，但是 方法内部怎么知道 \u0026ldquo;helloWorldService\u0026rdquo; 对应的是 类呢？ 所以，我们就可以分析出来，在调用 的构造方法时，也就是第一行代码，会做这些事情： 解析类 ，得到扫描路径 遍历扫描路径下的所有类，如果发现某个类上存在 、 等注解，那么 Spring 就把这个类记录下来，存在一个 中，比如 。（实际上，Spring源码中确实存在类似的这么一个Map，叫做BeanDefinitionMap） Spring 会根据某个规则生成当前类对应的 ，作为 key 存入 Map，当前类作为 value 这样，当调用 时，就可以根据 找到类 ，从而可以创建对象了。 Bean的创建过程 那么 Spring 中到底是如何创建一个 Bean 的呢，这就是 Bean 的生命周期。大致过程如下： 利用该类的构造方法来创建一个对象（如果该类中有多个构造方法，Spring 则会进行选择，这个叫推断构造方法） 得到一个对象后，Spring 会判断该对象是否存在被 注解了的属性，把这些属性找出来并由 Spring 进行赋值（依赖注入） 依赖注入后，Spring 会判断对象是否实现了 接口、 接口、 接口，如果实现了，就表示当前对象必须实现该接口中所定义的 、 、 方法，那Spring 就会调用这些方法并传入相应的参数（Aware回调） Aware回调后，Spring 会判断该对象中是否存在某个方法被 注解了，如果存在，Spring 会调用当前对象的此方法（初始化前） 紧接着，Spring 会判断该对象是否实现了 接口，如果实现了，就表示当前对象必须实现该接口中的 方法，那 Spring 就会调用当前对象中的 方法（初始化） 最后，Spring 会判断当前对象是否需要 AOP，如果不需要那么 Bean 就创建完了；如果需要 AOP，则会进行动态代理并生成一个代理对象作为 Bean（初始化后） 通过最后一步，我们可以发现，当 Spring 根据 来创建一个 Bean 时： 如果不用进行 AOP，那么 Bean 就是 类的构造方法所得到的对象； 如果需要进行 AOP，那么 Bean 就是 的代理类所实例化得到的对象，而不是 本身得到的对象。 Bean 对象创建出来后： 如果 Bean 是单例的，那么会把该 Bean 对象存入一个 ，Map 的 key 为 ，value 为 Bean 对象。这样下次 时就可以直接从 Map 中拿到对应的 Bean 对象了。（实际上，在Spring源码中，这个Map就是单例池） 如果当前 Bean 是原型 Bean，那么后续没有其他动作，不回存入 Map，而是在下次 getBean 方法执行时再次执行创建过程，得到一个新的 Bean 对象。 推断构造方法 Spring 在基于某个类生成 Bean 的过程中，需要用该类的构造方法来实例化得到一个对象，但是如果一个类存在多个构造方法，Spring 会使用哪个呢？ Spring 的判断逻辑如下： 如果一个类只存在一个构造方法，那么不管该构造方法是无参构造方法还是有参构造方法，Spring 都会用这个方法； 如果一个类存在多个构造方法 这些构造方法中，存在一个无参的构造方法，那么 Spring 就会用这个无参的构造方法 这些构造方法中，不存在一个无惨的构造方法，那么 Spring 就会报错 Spring 的设计思想是这样的： 如果一个类只有一个构造方法，那么没得选择，只能用这个构造方法； 如果一个类存在多个构造方法，Spring 不知道如何选择，就会看是否存在无参的构造方法，因为无参构造方法本身表示一种默认的意义； 不过如果某个构造方法加了 注解，那么就表示程序员告诉 Spring 就用这个加了注解的方法，Spring 就会用这个加了 注解的方法 那么如果 Spring 选择了一个有参的构造方法，在调用构造方法时，需要传入参数，那这个参数怎么来的？ Spring 会根据入参的类型和入参的名字寻找 Bean 对象（以单例 Bean 为例，Spring 会从单例池那个 Map 中去找）： 先根据入参类型找，如果只找到一个，那就直接用来作为入参； 如果根据入参类型找到多个，则再根据入参名字来确定唯一一个 最终如果没有找到会报错无法创建当前 Bean 对象 确定用哪个构造方法，确定入参的 Bean 对象，这个过程就叫做推断构造方法。 AOP大致流程 AOP 就是进行动态代理。在创建一个 Bean 的过程中，Spring 在最后一步会去判断当前正在创建的这个 Bean 是不是需要进行 AOP，如果需要则会进行动态代理。 如何判断当前 Bean 对象是否需要进行 AOP： 找出所有的切面 Bean； 遍历切面中的每个方法，看是否写了 、 等注解； 如果写了，则判断对应的 是否和当前 Bean 对象的类是否匹配 如果匹配则表示当前 Bean 对象有匹配的 ，需要进行 AOP 利用 cglib 进行 AOP 的大致流程： 生成代理类 ，代理类继承 ； 代理类中重写了父类的方法，比如 中的 test 方法； 代理类中还会有一个 target 属性，该属性的值为被代理对象（就是通过 类推断构造方法实例化出来的对象，进行了依赖注入、初始化等步骤的对象） 代理类中的 test 方法被执行时的逻辑如下： 执行切面逻辑（ ） 调用 当我们从 Spring 容器得到 的 Bean 对象时，拿到的就是 所生成的对象，也就是代理对象。 HelloWorldService 代理对象.test()\u0026mdash;\u0026gt;执行切面逻辑\u0026mdash;\u0026gt;target.test()，注意target对象不是代理对象，而是被代理对象。 Spring事务 在我们在某个方法上加上了 注解后，就表示该方法在调用时会开启 Spring 事务，而这个方法所在的类对应的 Bean 对象会是该类的代理对象。 Spring 事务的代理对象执行某个方法时的步骤： 判断当前执行的方法是否存在 注解； 如果存在，则利用事务管理器 新建一个数据库连接； 修改数据库连接的 为 false； 执行 ，执行程序所写的业务逻辑代码，也就是执行SQL； 执行完了之后如果没有异常，则提交，否则进行回滚。 Spring 事务是否会失效的判断标准：某个加了 注解的方法被调用时，要判断到底是不是直接被代理对象调用的，如果是则事务会生效，如果不是则失效。 "],["ssh错误no matching host key type found. Their offer ssh-rsa","2022年10月10日","/2022/10/solve-no-matching-host-key-their-offer-ssh-rsa/"," 问题 macOS升级后，发现连接某些之前连接得好好的服务器突然无法连接，提示如下错误： Unable to negotiate with x.x.x.x port 2222: no matching host key type found. Their offer: ssh-rsa 解决办法 当然, 每次连接敲这么一长串也不太友好。 编辑用户 ssh 配置 ，对于无法成功连接的host，增加配置项: 完整的配置可能看起来像这样: 或者，像我一样的懒人: 为什么会这样 根据 OpenSSH Release Notes Future deprecation notice It is now possible[1] to perform chosen-prefix attacks against the SHA-1 algorithm for less than USD$50K. In the SSH protocol, the “ssh-rsa” signature scheme uses the SHA-1 hash algorithm in conjunction with the RSA public key algorithm. OpenSSH will disable this signature scheme by default in the near future. Note that the deactivation of “ssh-rsa” signatures does not necessarily require cessation of use for RSA keys. In the SSH protocol, keys may be capable of signing using multiple algorithms. In particular, “ssh-rsa” keys are capable of signing using “rsa-sha2-256” (RSA/SHA256), “rsa-sha2-512” (RSA/SHA512) and “ssh-rsa” (RSA/SHA1). Only the last of these is being turned off by default. 也就是说 8.8p1 版的 openssh 的 ssh 客户端默认禁用了 算法，但是对方服务器只支持 ，当你不能自己升级远程服务器的 openssh 版本或修改配置让它使用更安全的算法时，在本地 ssh 针对这些旧的ssh server重新启用 也是一种权宜之法。 参考链接 https://www.openssh.com/releasenotes.html https://www.openssh.com/legacy.html "],["hexo Next主题设置和优化","2022年07月07日","/2022/07/hexo-next-theme/"," 主题样式优化 修改打赏字体不闪动 修改文件 ，然后注释其中的函数 和 ，如下： 采用多说时文章评论数目不显示 当采用多说评论系统的时候，不知道因为什么原因，文章的评论数目不能正常显示，分类后面不能正常显示评论数目，但有分隔号。 修改文件 ，将原来的代码： 改为： 使文章始终不显示评论数目，而不仅仅在手机模式下。 修改内链文字样式 原来版本的内链样式跟默认的字体很类似，这里进行修改。将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。修改文件 ，添加如下css样式： 选择 是为了不影响标题，选择 是为了不影响首页“阅读全文”的显示样式。 参考链接 http://www.wuxubj.cn/2016/08/Hexo-nexT-build-personal-blog/ 修改小段的代码样式 主题原来的小段代码样式跟默认文章字体有点类似，这里可以修改其样式显示的更清晰点。 修改文件 文件，找到其中的 段代码，改为如下形式： 其中的 就是字体对应的颜色， 对应背景颜色。 修改侧边栏头像为圆形 修改文件 ，修改其中的 段代码，改为如下形式： 如果需要添加鼠标停留在上面发生旋转效果，那么添加如下代码： 参考链接 http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/ 多说CSS修改 隐藏评论框底部分享到QQ空间按钮 隐藏底部版权信息 参考链接 http://www.360doc.com/content/15/0126/21/21724608_444033903.shtml http://shenchaofei.cn/duoshuo-comment-box-css-custom/328.html http://dev.duoshuo.com/docs/4ff1cfd0397309552c000017 搜索功能 博客的站内搜索网上一般说用 搜索，尝试了下，但是提示只有一个月的免费试用，遂放弃改用 。 安装hexo-generator-search： 编辑站点的配置文件，Hexo目录下的_config.yml文件，新增以下内容： 文章链接唯一化 也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装此插件后，不要在 模式下更改文章文件名，否则文章将成空白。 安装： 在 中查找代码 ，将其更改为: 在 中添加如下代码： 可选择模式： crc16 \u0026amp; hex crc16 \u0026amp; dec crc32 \u0026amp; hex crc32 \u0026amp; dec 文章底部增加版权信息 新版的 主题应该已经支持文章版权的相关设置，在对应的目录下可以看到带有 相关的代码。 在这里，我们不使用主题本身的版权设置，改用我们自定义的版权信息说明，类似本文下方的表现形式。 注：类似本文的版权信息，需要增加相关的代码来实现。这个功能不是我自己写的，代码和想法皆出自于务虚笔记（作者博客名称），当初是请教作者并且得到授权允许发布相关文章来说明如何实现类似的样式。作者个人链接是http://www.wuxubj.cn/ ，转载这部分内容请务必注明作者及其个人链接。 作者对于 主题的优化可以参考 在目录 添加 ： 在目录 下添加 ： 修改 ，在代码 之前添加增加如下代码： 修改 文件，在最后一行增加代码： 保存重新生成即可。 这样当发布一篇博文是，要在该博文下面增加版权信息的显示，需要在 Markdown 中增加 的设置，类似 "],["lumen定时任务","2022年07月07日","/2022/07/lumen-schedule/","实现定时任务功能的步骤如下。 任务逻辑实现 在目录 目录下新建 文件，用来实现定时任务的具体逻辑，代码结构如下： 上述代码中， 代码执行命令， 函数即是具体逻辑的实现函数，这里我们实现一个简单的LOG打印。 定时任务配置 然后在 增加对该定时任务的配置： 如上述代码， 中配置定时任务的实现类，然后在 函数中增加对该定时任务的时间等配置。 表示每分钟，可以使用更多的时间配置，具体查看相关文档。 用来根据给定的测试的结果来限制任务的执行，只有当 返回 时才执行。 默认情况，即便有相同的任务还在运行，调度内的任务依旧会被执行， 可以用来解决这个问题。 值得注意的是， 不能和 共用，即使 返回值为 。所以当有 需求时，是否执行该任务的判断需要放在 函数中。 执行 上述代码创建完成后，我们可以通过命令 来执行一次定时任务，用来验证代码逻辑是否正确，该命令会立即运行定时任务，并且会忽略 的判断。 确认逻辑正确后，需要把定时任务加到 配置中去，让它可以定时执行。 这里可以配置两个位置，一个是在 目录下，新增定时任务文件，形式如下： 里面的配置是系统级别的，需要指定用户执行。 表示开始执行全部的定时任务。 还有一种方法是输入命令 进行编辑，文件在 目录下， 会以当前用户去执行脚本。 可以查看当前已经设定的定时任务。 "],["ssh证书登录","2022年07月07日","/2022/07/use-ssh-key-to-login/"," 证书登陆的步骤 客户端生成证书:私钥和公钥，然后私钥放在客户端，妥当保存，一般为了安全，访问有黑客拷贝客户端的私钥，客户端在生成私钥时，会设置一个密码，以后每次登录ssh服务器时，客户端都要输入密码解开私钥 服务器添加信用公钥：把客户端生成的公钥，上传到ssh服务器，添加到指定的文件中，这样，就完成ssh证书登录的配置了。 假设客户端想通过私钥要登录其他ssh服务器，同理，可以把公钥上传到其他ssh服务器。 真实的工作中:员工生成好私钥和公钥(千万要记得设置私钥密码)，然后把公钥发给运维人员，运维人员会登记你的公钥，为你开通一台或者多台服务器的权限，然后员工就可以通过一个私钥，登录他有权限的服务器做系统维护等工作，所以，员工是有责任保护他的私钥的。 客户端建立私钥和公钥 会在 目录下生成两个文件，分别是私钥 (id_rsa) 与公钥 (id_rsa.pub)。另外就是私钥的密码了，如果不是测试，不是要求无密码ssh，不能输入空(直接回车)，要妥当想一个有特殊字符的密码。 服务端配置 要注意的是，禁止密码登录要等ssh证书全部配置好以后再设置，不然证书没配置好、密码也不能登录到时候就悲剧了。 客户端公钥上传到服务器 在客户端执行命令： 在服务端执行命令： 如果提示文件不存在，那么要先创建 文件（这里以root用户为例）： 重启 Centos7重启ssh命令： Centos6.4重启ssh命令： 客户端通过私钥登录服务端 参考链接 http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646346.html "],["后缀表达式转中缀表达式","2022年07月07日","/2022/07/c73f8444-4476-49a9-8e59-39f32482b306/"," 问题描述 将由数字和四则运算符组成的后缀表达式变换为中缀表达式，输入的后缀表达式的运算符不超过15个，要求转换后的中缀表达式中不出现不必要的括号。例如，整个表达式的括号要省略，不影响计算顺序括号要省略。 输入形式 程序从标准输入读入一行字符串，是一个合法的后缀表达式，数字和运算符之间由空格分隔。数字可以是带小数部分的浮点数。 输出形式 向标准输出打印结果，输出只有一行，是转换后的中缀表达式。并且： 各分量（包括括号）紧密输出，不使用空格进行分隔； 在转换后的各运算数的出现顺序不变； 浮点数保留输入时的小数位数。 代码实现 "],["如何写好git commit message","2022年07月07日","/2022/07/how-to-write-git-commit-message/","任何软件项目都是一个协作项目，它至少需要2个开发人员参与，当原始的开发人员将项目开发几个星期或者几个月之后，项目步入正规。不过他们或者后续的开发人员仍然需要经常提交一些代码去修复bug或者实现新的feature。我们经常有这种感受：当一个项目时间过了很久之后，我们对于项目里面的文件和函数功能渐渐淡忘，重新去阅读熟悉这部分代码是很浪费时间并且恼人的一件事。但是这也没法完全避免，我们可以使用一些技巧尽可能减少重新熟悉代码的时间。commit messages 可以满足需要，它也反映了一个开发人员是否是良好的协作者。 编写良好的Commit messages可以达到3个重要的目的： 加快review的流程 帮助我们编写良好的版本发布日志 让之后的维护者了解代码里出现特定变化和feature被添加的原因 这里有一个比较好的示例，可以参考一下。 关于Commit messages 的格式有多种，不同的社区可能有各自不同的格式，本文介绍的这种做参考即可。 Commit messages基本语法 Commit messages的基本语法 表示提交类别， 表示标题行， 表示主体描述内容。 的类别说明： feat: 添加新特性(feature) fix: 修复bug docs: 仅仅修改了文档 style: 仅仅修改了空格、格式缩进等等，不改变代码逻辑 refactor: 代码重构，即不是新增功能，也不是修改bug的代码变动 perf: 增加代码进行性能测试 test: 增加测试用例 chore: 改变构建流程、或者增加依赖库、工具等 Commit messages格式要求 Commit messages书写建议 尽可能多的提交，单个Commit messages包含的内容不要过多 标题行以Fix, Add, Change, Delete开始，采用命令式的模式。不要使用Fixed, Added, Changed等等 始终让第二行是空白，不写任何内容 主体内容注意换行，避免在git里面滚动条水平滑动 永远不在 git commit 上增加 -m 或 \u0026ndash;message= 参数，提交的时候git commit即可。 参考链接 Git 写出好的 commit message https://ruby-china.org/topics/15737 Git 的正确提交姿势 https://www.oschina.net/news/69705/git-commit-message-and-changelog-guide "],["Spring源码2-各模块介绍","2022年07月07日","/2022/07/introduction-to-spring-framework-modules/","Spring中的模块划分如下图所示，除了图中的spring-vitahlin外，还有24个模块： spring模块 1. framework-bom 通过该模块，可以解决Spring中的模块与其他框架整合时产生jar包版本的冲突，默认为空实现。 2. integration-tests spring的集成测试模块。 3. spring-aop 面向切面编程时使用。Spring通过\u0026quot;横切\u0026quot;的方式将贯穿于多业务中的公共功能独立抽取出来，形成单独的切面，并指定切面的具体动作，在需要使用该功能时，动态地将该功能切入到需要的地方。 4. spring-aspects 用来实现 框架的集成。 是一个通过Java扩展出之后的框架，框架里面定义了 AOP 的语法，通过特殊的编译器完成编译期间的代码植入，最后生成增强之后的 Class 文件。 5. spring-beans 完成spring框架的基本功能，里面定义了大量和Bean有关的接口、类和注解。例如，bean定义的顶层接口 ，Bean装配相关的注解 、 、 ，用来创建bean的工厂接口 和一些具体的工厂方法等。 6. spring-context 用来实现spring的上下文功能，以及spring的IOC，例如初始化spring容器时所使用的 接口和常用的抽象实现类 或者 等。 7. spring-context-indexer 用来创建spring应用启动时候所选组件的索引，以提高应用的启动速度。通常情况下，应用启动的时候会扫描类路径下所有组件，但是如果组件特别多，会导致应用启动特别慢。该模块可以在应用的编译器对应用的类路径下的组件创建索引，在启动的时候通过索引去加载和初始化组件，可以大大提高应用启动速度。 8. spring-context-support 用来提供spring上下文的一些扩展模块，例如实现邮件服务、视图解析、缓存的支持、定时任务调度等。 9. spring-core spring的核心功能实现，例如控制反转(IOC)、依赖注入(DI)、 以及 的实现。 10. spring-expression 提供spring表达式语言等支持，SPEL。 11. spring-instrument 实现spirng对服务器的代理接口功能实现，实现的是类级别或者 级别的代理功能。 12. spring-jcl 通过适配器设计模式实现的一个用来统一管理日志的框架，对外提供统一的接口，采用“适配器”将日志的操作全部委托给具体的日志框架，提供了对多种日志框架的支持。 13. spring-jdbc spring对JDBC(Java Data Base Connector)功能的支持，里面定义了用于操作数据的多种API，常用的即 JdbcTemplate。通过模版设计模式将数据库的操作和具体业务分离，降低了数据库操作和业务功能的耦合。 14. spring-jms 对Java消息服务的支持，对JDK中的JMS API进行了简单的封装。 15. spring-messaging 实现基于消息来构建服务的功能。 16. spring-orm 提供一些整合第三方ORM框架的抽象接口，用来支持与第三方ORM框架进行整合，例如：MyBatis、Hibernate、Spring JPA等。 17. spring-oxm spring用来对对象和 xml(Object/xml) 映射的支持，完成 xml 和 object 对象的相互转换。 18. spring-r2dbc r2dbc 是支持使用反应式编程API访问关系型数据库的桥梁，定义统一接口规范，不同数据库厂家通过实现该规范提供驱动程序包。 19. spring-test Spring对Junit测试框架的简单封装，用来快速构建应用的单元测试功能及Mock测试。 20. spring-tx 对一些数据访问框架提供的声明式事务或者编程式事务（通过配置文件进行事务的声明）的支持。例如 Hibernate、Mybatis、JPA 等。 21. spring-web 用来支持 web 系统的功能。例如文件上传、与JSF的集成、规律器 Filter 的支持等。 22. spring-webflux spring5中新增的一个通过响应式编程来实现 web 功能的框架。内部支持了 reactive 和非阻塞式的功能。例如可以通过tcp的长连接来实现数据传输。webmvc的升级版，webmvc是基于 servlet 的，而 webflux 是基于 reactive 的。 23. spring-webmvc 用来支持SpringMVC的功能，包括了和SpringMVC框架相关的所有类或者接口，例如常用的DispatcherServlet、ModelAndView、HandlerAdaptor等。另外提供了支持国际化、标签、主题、FreeMarker、Velocity、XSLT的相关类。注意：如果使用了其他类似于smart-framework的独立MVC框架，则不需要使用该模块中的任何类。 24. spring-websocket Spring对websocket的简单封装，提供了及时通信的功能，常用于一些即时通讯功能的开发，例如：聊天室。 "],["Spring源码1-编译5.3.10源码","2022年07月07日","/2022/07/build-spring-source-code/"," 源码下载 Github源码地址：https://github.com/spring-projects/spring-framework/tree/v5.3.10 下载后将目录 重命名为 。 注意gitignore中不能忽略 目录下的 目录。 编译 跳转到源代码目录，执行 命令： 出现如下的 后，用 打开项目即可： 新建测试模块 -\u0026gt; -\u0026gt; ，新建测试模块 ，然后添加所需依赖： 模块创建完成后，我们还需要创建测试类来验证导入的 源代码能否实现依赖注入。 创建测试类，对应的代码： 执行 函数，结果如下： 成功打印地址和输出内容，依赖注入验证成功，但是 gradle 每次都会执行 Task 内容。需要修改 Gradle 的配置，指定 Gradle 为 ，如图所示： image.png 再次执行结果如下： image.png 执行正常，接下来就可以调试spring源代码了。 参考 https://blog.csdn.net/weixin_43405771/article/details/106313378 "],["git忽略设置","2022年07月07日","/2022/07/gitignore-settings/","在项目目录下新建 文件， 文件对其所在的目录及所在目录的全部子目录均有效。通过将.gitignore文件添加到仓库，其他开发者更新该文件到本地仓库，可以共享同一套忽略规则。 基本的配置规则 忽略＊.o和＊.a文件 ＊.[oa] 忽略＊.b和＊.B文件,my.b除外: ＊.[bB] !my.b 忽略dbg文件和dbg目录 dbg 只忽略dbg目录，不忽略dbg文件 dbg/ 只忽略dbg文件，不忽略dbg目录 dbg !dbg/ 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内 /dbg 从Github上下载忽略文件 Github上面有个项目专门收集各种忽略文件，我们可以直接从中下载对应的忽略文件到本地项目中进行应用，地址如下：gitignore 这里以 文件为例，找到该文件，点击文件的 查看文件的地址，然后用如下命令下载 ： 链接地址为上述中查看的地址，下载后即可。 表示把下载的文件重新命令为 。 忽略规则不生效解决方法 有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是 .gitignore 只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore是 无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 参考链接 https://segmentfault.com/q/1010000003410211 http://www.pfeng.org/archives/840 "],["shell参数简单介绍","2022年07月07日","/2022/07/brief-introduction-of-shell-param/","如下一个命令： 我们称 为选项，它需要一个参数，即 , 也是一个选项，但它不需要参数。 我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的， 可以直接写在 后面，即 。 以上述的命令为例： : ，即命令本身，相当于C/C++中的 : ，第一个参数 : ，第二个参数 , \u0026hellip; ：类推 : 参数的个数，不包括命令本身，上例中 为 4 : 参数本身的列表，也不包括命令本身，如上例为 、 、 、 : 和 相同，但 和 并不同， 将所有的参数解释成一个字符串，而 是一个参数数组。 参考链接 http://blog.csdn.net/qzwujiaying/article/details/6371246 "],["左移位和右移位","2022年07月07日","/2022/07/left-shift-and-right-shift/"," 左移位 操作符： 值最左边的几位被丢弃，右边多出来的几个空位则由0补齐。 例如： 右移位 操作符： 从左边移入新位时，可以选择两种方案： 逻辑移位：左边移入的用0填充 算术移位：左边一如的位由原来该值的符号位决定，符号位为1则移入的位均为1，符号位为0则移入的位均为0 例如： 注意：标准说明无符号值执行的所有移位操作都是逻辑移位，对于有符号值，到底是采用逻辑移位还是算术移位取决于编译器。 "],["maxOS环境下终端配置","2022年07月07日","/2022/07/mac-terminal/","终端软件很多，比如很流行的终端软件iTerm2 ，但这里不做介绍，macOS其实原生自带了终端工具 Terminal，我们来了解一下如何美化。 字体安装 大部分主题都需要特殊的字体支持，所以一开始我们需要下载这些 字体。 字体下载：https://github.com/powerline/fonts 可以按如下命令下载并导入： Terminal主题美化 下载主题美化Terminal，下载地址：https://github.com/mbadolato/iTerm2-Color-Schemes 下载到本地后，打开Terminal，导入所选主题即可，如图所示： Terminal主题 这里导入主题 OneHalfDark，效果如下： OneHalfDark主题效果 zsh配置 主题美化后，我们需要安装一下插件来优化 zsh 操作。 首先安装 zinit，用它来管理 zsh 插件，关于 zinit 的介绍网上很多，主要特点是快并且易于配置，一个 .zshrc文件即可拷贝全部配置。参考链接： Zsh \u0026amp; Zinit 配置舒服的终端环境 使用 zinit 管理 zsh 插件 完美代替 Antigen 加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程 通用配置： 安装完成后，我们还需要安装插件来优化 zsh。 主题优化 zsh主题 powerlevel10k zshrc 代码： 安装完成后，终端输入 来自定义p10k主题配置。 参考链接：https://github.com/romkatv/powerlevel10k 语法高亮 参考链接：https://github.com/zdharma-continuum/fast-syntax-highlighting 如果需要 命令也能高亮颜色的话，还需要如下配置： 操作优化 目录快速跳转 zsh-z 参考链接：https://github.com/agkozak/zsh-z 该插件需要 支持，可以通过 安装： 终端vim模式 zsh-vi-mode 参考链接：https://github.com/jeffreytse/zsh-vi-mode "],["如何理解复杂的指针或引用语句","2022年07月07日","/2022/07/how-to-understand-complex-pointer-or-reference-statements/","面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的含义。 如： 离变量最近的符号（此例中\u0026amp;r的符号是\u0026amp;）对变量的类型有最直接的影响，因此r是一个引用，声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型表明指针r引用的是一个int指针。 "],["Mysql如何选择合适的索引","2022年04月04日","/2022/04/mysql-how-to-choose-the-right-index/"," 示例表 表结构 测试数据 不同的索引选择 我们用一个查询语句来做示例，同样的查询条件，仅仅是查询参数的不同。 全表扫描示例 覆盖索引示例 走索引示例 可以看到，上述3种情况，mysql选择了不同的查询方案。 mysql最终选择是否走索引或者一张表涉及多个索引最终选择哪个索引，我们可以用trace工具来一查究竟。 trace介绍 用法 开启 trace 工具会影响 mysql 性能，所以只能临时分析 sql 使用，使用后应该立即关闭。 使用trace工具查看语句： 结果分析 上述 json 结果中给出大部分关键字段的注释，可以看到当前执行语句，mysql分析全表扫描比走索引查询的成本 cost 更低，所以选择了全表扫描。 "],["Mysql索引优化实践","2022年04月04日","/2022/04/mysql-indexing-optimization-practices/"," 示例表 表结构 表数据 联合索引第一个字段用范围查询 会不会走索引 联合索引第一个字段就用范围查找不会走索引，mysql内部可能觉得第一个字段就用范围查找，结果集应该很大，回表效率不高，还不如全表扫描。 强制走索引效果 使用了强制走索引让联合索引第一个字段范围查找也用索引，扫描的 看上去也少了点，但最终但查找效率不一定会比全表扫描高，因为回表效率不高。 强制走索引和不走索引效率对比 我们先关闭查询缓存，避免影响查询结果。 不走索引结果 强制走索引结果 可以看到，强制走索引的效率甚至还不如不走索引的执行效果。 如何优化？ 我们可以使用覆盖索引来优化。什么是覆盖索引？ 创建一个索引，该索引包含查询中用到的所有字段，称为“覆盖索引”。 使用覆盖索引，MySQL 只需要通过索引就可以查找和返回查询所需要的数据，而不必在使用索引处理数据之后再进行回表操作。 覆盖索引可以一次性完成查询工作，有效减少IO，提高查询效率。 in和or查询 是否会走索引？ 在数据量比较大的情况下会走索引，在表记录不多的情况会选择全表扫描。 大数据量情况 可以看到， 为 用到了索引。 小数据量情况 复制同样结构的表，往里面插入3条数据： 查询语句： 执行结果： 为 ，走的是全表扫描。 like 查询 会不会走索引？ 大数据量查询 分析结果： 小数据量查询 所以， 语句一般情况下都会走索引，为什么呢？这里其实是用到了索引下推优化。 索引下推 对于辅助的联合索引 ，正常情况按照最左前缀原则，查询语句只会走 字段索引， 因为 字段过滤完，得到的索引行里的 和 是无序的，无法很好的利用索引。 在Mysql5.6之前的版本，这个查询只能在联合索引里匹配到名字是 开头的索引， 然后拿这些索引对应的主键逐个回表，到主键索引上找出对应记录，再比较 和 两个字段的值是否符合。 Mysql5.6 引入了索引下推优化，可以在索引遍历过程中，对索引包含的所有字段做判断，过滤掉不符合条件的记录再回表，可以有效的减少回表次数。 使用了索引下推之后，上面那个查询在联合索引里匹配到名字符合的索引之后，同时还会在索引里面过滤 和 这两个字段， 拿着过滤完剩下的索引的主键ID再回表。索引下推会减少回表次数，对于InnoDB引擎的表索引下推只能用于二级索引， InnoDB的主键索引树叶子节点上保存的是全行数据，所有这个时候索引下推并不会减少查询全行数据的效果。 范围查找是否会用到索引下推？ 没有。猜测原因：估计应该是Mysql认为范围查找过滤的结果集过大， 在绝大多数情况下过滤后的结果集小，所以mysql选择给 用了索引下推优化， 当然这也不是绝对的，有时 也可能不用索引下推。 order by 与group by case1: order by用到了联合索引的中间字段 最左前缀法则，中间字段不能断，因此查询用到了 索引，从 也能看出。 列用在了排序之中，因为 里面没有 。 case2: order by用到了联合索引的最后一个字段 ，查询使用了 索引。由于用了 进行排序，跳过了 ，出现了 。 case3 查询只用到了索引 ， 和 用于排序，无 。 case4 和case2 中结果一样。 case5 与 case4 对比，因为 为常量，在排序中被优化，所以索引未颠倒，不会出现 。 case6 虽然排序的字段与索引顺序一样，且 ** 默认升序**，这里 变成了降序，导致与索引的排序方式不同， 从而产生了 。Mysql8以上版本有降序索引可以支持该查询方式。 case7 对于排序来说，多个相等条件等于范围查询。 case8 可以看到，上述查询并不会用到索引。但是可以使用覆盖索引进行优化。 优化总结 mysql支持两种方式的排序 和 ， 指扫描索引本身完成排序。 效率高， 效率低。 order by 满足两种情况会使用 Using index order by 语句使用索引最左前列 使用 where 子句与 order by 子句条件列组合满足索引最左前列 尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则 如果 order by 的条件不在索引列上，就会产生 Using filesort 能用覆盖索引尽量用覆盖索引 group by 与 order by 很类似，实质是先排序后分组，遵循索引创建顺序的最左前缀法则。对于 group by 的优化如果不需要排序可以加上 order by null禁止排序。注意，where 高于 having，能写在 where 中的限定条件就不要去having 限定了。 Using filesort文件排序原理 filesort 文件排序方式 单路排序 一次性取出满足条件所有字段，然后在 sort buffer 中进行排序；用 trace 工具可以看到 sort_model 信息里面显示 \u0026lt;sort_key, additional_fields\u0026gt; 或者 \u0026lt;sort_key, packed_additional_fields\u0026gt; 双路排序 又叫回表排序方式。先根据对于条件取出排序字段和可以直接定位行数据的行ID，然后在 sort buffer 中进行排序，排序完成后需要再次取回其他需要的字段；用trace工具可以看到 sort_model 信息里面显示 \u0026lt;sort_key, rowid\u0026gt; 什么时候用单路排序什么时候用双路排序？ mysql 通过比较系统变量 max_length_for_sort_data(默认1024字节)的大小和需要查询的字段总大小来判断使用哪种排序模式 如果字段总长度小于max_length_for_sort_data，使用单路排序 字段总长度大于max_length_for_sort_data，使用双路排序 filesort文件排序示例 单路排序示例 单路排序过程 从索引name找到第一个满足条件name=\u0026lsquo;lilei\u0026rsquo; 的主键ID 根据主键ID取出整行所有字段的值，存sort_buffer中 从索引name找到下一个满足条件的主键ID 重复2，3步骤知道条件不满足 name=\u0026lsquo;lilei\u0026rsquo; 对sort_buffer中的数据按照字段position进行排序 返回结果给客户端 双路排序示例 可以看到这里的，sort_mode值为\u0026lt;sort_key, rowid\u0026gt;，这里已经变为双路排序。 双路排序过程 从索引name找到第一个满足条件name=\u0026lsquo;lilei\u0026rsquo; 的主键ID 根据主键ID取出整行，把排序字段position和主键ID这两个字段放到sort_buffer中 从索引name找到下一个满足条件的主键ID 重复2，3步骤知道条件不满足 name=\u0026lsquo;lilei\u0026rsquo; 对sort_buffer中的字段position和主键ID按照字段position进行排序 遍历排序好的ID和字段position，按照主键ID值回到原表中取出所有字段的值返回给客户端 两种排序方式对比 单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键 和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。 如果 MySQL 排序内存 sort_buffer 配置的比较小并且没有条件继续增加了，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在sort_buffer 中一次排序更 多的行，只是需要再根据主键回到原表取数据。 如果 MySQL 排序内存有条件可以配置比较大，可以适当增大max_length_for_sort_data 的值，让优化器 优先选择全字段排序(单路排序)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。 所以，MySQL通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。 注意，如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增 大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。 分页查询优化 普通的分页查询 上述查询从表中取出从10000开始的5行记录。看似只查询了5条记录，实际上条SQL是先读取10005条记录，然后抛弃前10000条记录读到后面10条想要的记录。因此要查询一张大表比较靠后的数据，执行效率是非常低的。 常见的优化 自增且连续的主键排序的分页查询 当ID都是自增且连续主键排序，可以将上述查询换成: 缺点： 在很多场景不实用，因为表中可能某些记录被删，主键不连续导致结果不一致。 如果原来SQL 是order by 非主键的字段，按照这种优化会导致两条SQL结果不一致。 非主键字段排序的分页查询 查询并没有使用name字段的索引。具体原因是扫描整个索引并查找到没有索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引。 那么如何优化呢？ 关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，再根据主键查到对应的记录，SQL改写如下： "],["Mysql索引优化规则","2022年04月04日","/2022/04/mysql-indexing-optimization-rules/"," 示例表 索引优化规则 1. 最左匹配原则 如果索引了多列，要遵守最左匹配原则。查询从索引最左前列开始并且不跳过索引中间的列。 2. 不在索引列上做操作 不在索引列上做任何操作(计算、函数、类型转换(自动/手动))，会导致索引失效而转向全表扫描。 3. 存储引擎不能使用索引中范围条件右边的列 走索引示例 不走索引示例 4. 尽量使用覆盖索引，减少 select * 覆盖索引示例 非覆盖索引select * 5. 使用!=, \u0026lt;\u0026gt;, not in, not exist的时候不会用到索引 \u0026lt; 小于、 \u0026gt; 大于、 \u0026lt;=、\u0026gt;= 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引 6. is null, is not null一般情况下也无法用到索引 7. like以通配符开头(\u0026rsquo;$abc\u0026hellip;\u0026rsquo;)索引会失效 如何解决 索引失效问题？ 覆盖索引 使用覆盖索引，查询字段必须是建立覆盖索引字段，例如 搜索引擎 如果不能使用覆盖索引，则可借助搜索引擎，如ES。 8. 字符串不加单引号会导致索引失效 这其实是类型转换的问题 9. 少用or或者in 少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。例如： 10. 范围查询 是否会走索引？ 先给年龄字段添加单值索引 没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。 如何优化范围查询 优化方法：将大的范围拆分成多个小范围。 11. 不要在小基数字段上建立索引 索引基数是指这个字段在表里总共有多少个不同的值，比如性别字段，值不是男就是女，该字段基数就是2。 如果对这种小基数字段建立索引的话，还不如全表扫描来，因为你的索引树里面就包含男和女两种值，根本没办法快速的二分查找，那用索引就没有意义了。 一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，才能发挥出B+树快速二分查找的优势。 12. 长字符串可以采用前缀索引 尽量对字段类型比较小的列设计索引，比如说 tinyint之类的，因为字段类型比较小的话，占用磁盘空间也会比较小。那么当我们需要对 varhcar(255) 这种字段建立索引怎么办？ 我们可以针对这个字段对前20个字符建立索引，就是说把这个字段里对每个值对前20个字符放在索引树里，如 index(name(20), age, position)。 此时在where条件搜索的时候，如果是根据name字段来搜索，就会先到索引树里根据name字段的前20个字符去搜索，定位到前20个字符的前缀匹配的部分数据之后，再回到聚簇索引提前出来完整的name字段值进行比对。 但是如果要是order by name，那么此时name在索引树里面仅仅包含前20个字符，所以这个排序是没法用上索引的，group by也是同理。 13. where与order by冲突时优先where where与order by出现索引设计冲突时，到底是根据where去设计，还是针对order by去设计索引？ 一般都是让where条件去使用索引来快速筛选一部分指定顺序，接着再进行排序。 大多数情况基于索引进行where筛选可以更快速度筛选你要的少部分数据，然后做排序的成本会小很多。 14. 基于慢查询sql做优化 什么是慢查询？ MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。 具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。 long_query_time的默认值为10，意思是记录运行10秒以上的语句。 默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。 当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。 索引使用总结 假设索引 where 语句 索引是否被使用 where a=3 有，使用到了a where a=3 and b=5 有，使用到了a, b where a=3 and b=4 and c=5 有，使用到了a, b, c where b=3 没有 where b=3 and c=4 没有 where c=4 没有 where a=3 and c=5 有，但只使用了a where a=3 and b\u0026gt;4 and c=5 有，使用了a,b，c不能用在范围之后，b之后断了 where a=3 and b like \u0026lsquo;kk%\u0026rsquo; and c=4 有，使用到了a,b,c where a=3 and b like \u0026lsquo;%kk\u0026rsquo; and c=4 有，只用到了a where a=3 and b like \u0026lsquo;%kk%\u0026rsquo; and c=4 有，只用到了a where a=3 and b like \u0026lsquo;k%kk%\u0026rsquo; and c=4 有，使用到了a,b,c 相当于等于常量， 和 相当于范围。 "],["Mysql explain命令介绍","2022年04月04日","/2022/04/instruction-of-mysql-explain/"," 示例表和数据SQL id列 其中， 的编号就是 的序列号，有几个 就有几个 ，并且 id 的顺序是按 出现的顺序增长的，* 越大执行优先级越高， 相同从上往下执行， 为 最后执行*。 select_type列 表示对应行是简单还是复杂的查询。 simple 简单查询，查询不包含子查询和 primary, subquery, derived ，复杂查询中最外层的 ，包含在 中的子查询(不在 子句中) ，包含在 子句中的子查询。Mysql 会将结果存放在一个临时表中，也称为派生表。 用下面这个例子来了解 、 和 类型 其中，可以看到 id 最大值为3，表示有3个 语句， 的查询对应的子查询是 部分， 对应的是 语句， 则是最外层的 。 union 在 中的第二个和随后的 。 table列 这一列表示 的一行正在访问哪个表。它可以是下面值中的一个 这一行引用了ID值为M和N的表的联合。M 和 N 表示 的 行的 。 这一行引用了ID值为N的表所派生的表。派生的表可能是一个结果集，比如，FROM 子句中的子查询，表示当前查询依赖 的查询，于是先执行 的查询。 这一行引用了ID值为N的物化字查询的结果。参考：https://dev.mysql.com/doc/refman/5.7/en/subquery-materialization.html type列 表示关联类型或者访问类型，即 Mysql 决定如何查找表中的行，查找数据行记录的大概范围。 依次从最优到最差分别为： \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; ，一般来说，要保证查询达到 range 级别，最好达到 ref。 NULL值 mysql 能够在优化阶段分解查询语句，在执行阶段不需要访问表或者索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。 const, system mysql 能对查询对某部分进行优化并将其转为一个常量(可以看 show warnings 的结果)。用于 或 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。 是 的特例，表里只有一条元组匹配时为 。 可以看到， 的语句对应 ( ) 查询，此时比较主键是否相等，类型为 。 的查询 临时表中只有一条数据， 转为 。 eq_ref 主键或者唯一索引的所有部分被连接使用，最多只会返回一条符合条件的记录。这可能是在 之外最好的联接类型了，简单的 查询不会出现这种 。 ref 相比 ，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。 简单的 查询， 是普通索引（非唯一索引） 关联表查询，例如下面语句， 是表 字段 和 的联合索引，这里使用到 的左边前缀 部分。 range 范围扫描通常出现在 , , , , 等操作中，使用一个索引来检索给定范围的行 index 扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根结点开始查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为覆盖索引，二级索引一般比较小，所以这种比 ALL 快一些。 ALL 即全表扫描，扫描你的聚簇索引的所有叶子节点。通常这种情况就需要增加索引来优化了。 possible_keys列 这一列显示查询可能使用哪些索引来查找。 时可能 出现 有列，而 显示 的情况，是因为表中数据不多， 认为索引对此查询帮助不大，选择了全表查询。 如果该列是 ，则没有相关的索引。在这种情况下，可以通过检查 子句看是否可以创造一个适当的索引来提高查询性能，然后用 查询效果。 key列 显示 实际采用哪个索引来优化对该表的访问。 如果没有使用索引，该列值是 。如果想强制 使用或者忽视 列中的索引，可以使用 、 。 列key_len 显示了在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 比如表 的联合索引 由 和 两个 列组成，并且每个 是4字节。通过结果中的 可推断出查询使用列第一个列： 列来执行索引查找。 的计算规则 字符串， 和 ， 代表字符数，不是字节数，如果是 ，一个数字或者字母占1字节，如果是汉字占3字节。 存汉字长度为 字节， 存汉字长度为 字节，需要额外2字节用来存储字符串长度。 数值类型 tinyint 1字节 smallint 2字节 int 4字节 bigint 8字节 时间类型 date 3字节 timestamp 4字节 datetime 8字节 字段允许为 ，需要额外1字节记录是否为 索引的最大长度是768字节，当字符串过长时，mysql 会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。 ref列 显示了在 列记录的索引中，表查找值所用到的列或常量，常见的有 (常量)，字段名(例如 film.id) rows列 估计要读取并检测的行数，并不是结果集里面的行数，只是一个估计值。 filtered列 表示返回结果的行数占需读取行数(列 值)的百分比， 列的值越大越好， 列的值依赖于统计信息 Extra列 展示的是额外信息。常见的重要值如下： 1. Using index：使用覆盖索引 覆盖索引的定义：mysql 执行计划 结果里的 列有使用索引，如果 后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引， 里一般都有 。覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其他字段值。 覆盖索引 非覆盖索引 2. Using where 使用 语句来处理结果，并且查询的列未被索引覆盖。 3. Using index condition 查询的列不完全被索引覆盖， 条件是一个前导列的范围 4. Using temporary mysql 需要创建一张临时表来处理查询。出现这种情况一般需要进行优化，首先想到用索引来优化 没有索引，此时创建来临时表来 建立来 索引，此时查询时 是 ，没有用临时表 5. Using filesort 将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑用索引来优化。 使用外部排序 未创建索引，会浏览 整个表，保存排序关键字 和对应的 ，然后排序 并检索行记录。 利用索引优化 建立了 索引，此时查询时 是 。 6. Select tables optimized away 使用某些聚合函数(比如 、 )来访问存在索引的某个字段时 "],["rust安装和升级","2020年09月09日","/2020/09/install-and-upgrade-rust/"," 安装 使用 安装 ，安装 : 在 Rust 开发环境中，所有工具都安装在 目录中，您可以在这里找到包括 、 和 在内的 Rust 工具链。 查看 rust 版本 卸载 升级 "]]